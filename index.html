<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Art Exhibition - Liquid Glass Interface</title>
    <link rel="stylesheet" href="glass_surface.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #3b3b3b;
            background: linear-gradient(180deg,rgba(59, 59, 59, 1) 0%, rgba(84, 84, 84, 1) 42%, rgba(112, 112, 112, 1) 76%, rgba(120, 120, 120, 1) 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        button{
            /* Remove default browser appearance */
            -webkit-appearance: none; /* For Safari/Chrome */
            -moz-appearance: none;    /* For Firefox */
            appearance: none;         /* Standard property */

            /* Reset box model properties */
            background: none;
            border: none;
            padding: 0;
            margin: 0;

            /* Inherit font styles from parent */
            font: inherit;
            color: inherit;

            /* Remove default cursor and outline */
            cursor: default; /* or pointer if you want it to still be interactive */
            outline: none;
        }

        /* Ripple Grid Background */
        #rippleGridBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* z-index: 0; */
            pointer-events: none;
            overflow: hidden;
        }

        #rippleGridBackground canvas {
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* opacity: 0.9; */
            filter: blur(1.3px);
        }

        /* Canvas Background */
        .text-canvas-wrapper{
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* mix-blend-mode: hard-light; */
            /* z-index: 1; */
        }

        .bg-vignette{
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: #535353d2;

            /* fall back for Chromium/Firefox */
            mask-image: radial-gradient(ellipse 65% 65% at center,
                rgba(0,0,0,0) 85%,
                rgba(0,0,0,1) 100%);
            mask-repeat: no-repeat;
            mask-size: 100% 100%;
            mask-position: center;

            /* WebKit/Safari */
            -webkit-mask-image: radial-gradient(ellipse 65% 65% at center,
                rgba(0,0,0,0) 85%,
                rgba(0,0,0,1) 100%);
            -webkit-mask-repeat: no-repeat;
            -webkit-mask-size: 100% 100%;
            -webkit-mask-position: center;
        }

        #bgCanvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            opacity: 0.9;
            pointer-events: all;
            filter: blur(1.2px);
        }

        /* Main Content Wrapper */
        .main-wrapper {
            --message-transition-speed: 1.3s;
            --project-button-transition-speed: 0.35s;
            position: relative;
            /* z-index: 2; */
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        /* Chat Container */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 1.25rem; /* 20px */
            padding-bottom: 7.5rem; /* 120px */
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        .chat-space-before{
            margin-bottom: 0.94rem; /* 15px */
            display: flex;
            align-items: flex-start;
            gap: 0.63rem; /* 10px */
            width: 100%;
            max-width: 50rem; /* 800px */
            height: 50vh;
            justify-content: center;
            flex-shrink: 0;
        }

        .chat-space-after{
            margin-bottom: 0.94rem; /* 15px */
            display: flex;
            align-items: flex-start;
            gap: 0.63rem; /* 10px */
            width: 100%;
            max-width: 50rem; /* 800px */
            height: 50vh;
            justify-content: center;
            flex-shrink: 0;
        }

        /* Message Bubbles with enhanced opacity transition */
        .message {
            margin-bottom: 0.94rem; /* 15px */
            display: flex;
            align-items: flex-start;
            gap: 0.63rem; /* 10px */
            /* MAX WIDTH OF MESSAGE BUBBLE */
            max-width: 60%;
            /* max-width: 50rem;  */
            margin-bottom: 4vh;
            justify-content: center;
            transition: transform 1s cubic-bezier(.53,.23,.26,.92);
        }

        .message.user {
            margin-top: 12vh;
            flex-direction: row;
            /* justify-content: right; */
        }


        /* Corner glass highlight for glass surface effect */
        .glass-highlight-wrapper {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            border-radius: inherit;
            /* z-index: 0; */
            overflow: hidden;
            background: none;
            pointer-events: none;
            mask-composite: intersect;
            transition: all var(--project-button-transition-speed) cubic-bezier(.22,.31,.33,1.27);
        }
        .glass-highlight-wrapper.messages{
            mask-image: linear-gradient(to right, white, rgba(255, 255, 255, 0) var(--glass-message-mask-gradient-x)), linear-gradient(to top, white, rgba(255, 255, 255, 0) var(--glass-message-mask-gradient-y));
            opacity: var(--glass-message-opacity);
        }
        .glass-highlight-wrapper.buttons{
            mask-image: linear-gradient(to right, white, rgba(255, 255, 255, 0) var(--glass-button-mask-gradient-x)), linear-gradient(to bottom, white 30%, rgba(255, 255, 255, 0) var(--glass-button-mask-gradient-y));
            opacity: var(--glass-button-opacity);
        }
        .glass-highlight-wrapper.typings{
            mask-image: linear-gradient(to right, white, rgba(255, 255, 255, 0) 75%), linear-gradient(to top, white, rgba(255, 255, 255, 0) 40%);
            opacity: 0.3;
            transition: none;
        }

        .glass-highlight{
            position: absolute;
            pointer-events: none;
            background-color: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            
            border-radius: inherit;
            border-width: 2.5px; /* 2px */
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.7);
        }
        .glass-highlight.messages{
        }
        .glass-highlight.buttons{
        }
        .glass-highlight.typings{
        }

        .glass-highlight-tint{
            display: none;
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            /* background-color: rgb(7, 61, 162); */
        }

        /* Glass mix blend overlay */
        .glass-blend-overlay{
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            border-radius: inherit;
            pointer-events: none;
            overflow: hidden;
            transition: background 0.5s ease;
            /* display: none; */
            background-color: var(--blend-bg-color);

            mask-image: linear-gradient(to right, rgba(255, 255, 255, 0.3), white 7%, white 90%, rgba(255, 255, 255, 0.15));
        }

        /* Bottom Button Section */
        .button-section {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: none;
            padding: 0;
            margin-bottom: 1%;
            /* z-index: 100; */
            pointer-events: auto;
            display: flex;
            justify-content: center;
        }

        .button-scroll-container {
            overflow-x: auto;
            white-space: nowrap;
            padding: 1.25rem 1.25rem; /* 20px 20px */
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
            display: flex;
            justify-content: left;
            align-items: center;
            gap: 1.5rem; /* 24px */
            max-width: 100%;
        }

        .button-scroll-container::-webkit-scrollbar {
            height: 0.38rem; /* 6px */
        }

        .button-scroll-container::-webkit-scrollbar-track {
            background: none;
        }

        .button-scroll-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 0.19;
        }

        .button-wrapper{
            position: relative;
            display: inline-block;
            border-radius: 1.5rem;
            background: none;
        }

        /* Updated Project Buttons with Liquid Glass Effect */
        .project-button {
            --glass-button-mask-gradient-x: 70%;
            --glass-button-mask-gradient-y: 70%;
            --glass-button-opacity: 0.4;
            position: relative;
            /* isolation: isolate; */
            display: inline-block;
            width: 4.5rem; /* 70px */
            height: 4.5rem; /* 70px */
            flex-shrink: 0;
            border-radius: inherit;
            cursor: pointer;
            overflow: hidden;
            vertical-align: middle;
            transition: all var(--project-button-transition-speed) cubic-bezier(.22,.31,.33,1.27);
            background: none;
            border: none;
            /* box-shadow: inset 0 0 0.25rem 0 rgba(255, 255, 255, 0.3),
                        0 0.25rem 0.375rem rgba(0, 0, 0, 0.2),
                        0 0 0.9375rem rgba(0, 0, 0, 0.1); */
        }

        .project-button:hover:not(.disabled) {
            --glass-button-mask-gradient-x: 90%;
            --glass-button-mask-gradient-y: 90%;
            --glass-button-opacity: 0.6;
            transform-origin: 50% 50%;
            transform: scale3d(1.1, 1.1, 1);
            /* box-shadow: inset -0.13rem -0.31rem 0.31rem rgba(255, 255, 255, 0.05),
                        inset 0.19rem 0.69rem 0.63rem rgba(0, 0, 0, 0.12); */
        }

        .project-button.disabled {
            cursor: wait;
            /* opacity: 0.5 !important; */
            pointer-events: none !important;
        }

        .project-button-content {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            padding: 0;
        }

        .project-button img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* filter: saturate(0.7); */
            /* transition: filter 0.3s; */
            display: none;
        }

        .project-button:hover img {
            /* filter: saturate(1.2) brightness(1.1); */
        }

        /* Updated Message Content for Liquid Glass */
        .message-content {
            --glass-message-mask-gradient-x: 85%;
            --glass-message-mask-gradient-y: 70%;
            --glass-message-opacity: 0.3;
            --blend-bg-color: none;
            position: relative;
            isolation: isolate;
            /* max-width: 60%; */
            /* max-height: 60vh; */
            border-radius: 2rem; /* 18px */
            transition: all var(--message-transition-speed) cubic-bezier(.41,.29,.18,1.26), opacity 0.5s cubic-bezier(.83,.06,.88,.76);
            cursor: default;
            background: none;
            overflow: hidden;
            pointer-events: none !important;
            cursor: wait !important;
        }

        .message-content.sent{
            transition: all var(--project-button-transition-speed) cubic-bezier(.41,.29,.18,1.26);
            cursor: auto !important;
            pointer-events: auto !important;
        }

        .message-content.sent:hover {
            --glass-message-mask-gradient-x: 95%;
            --glass-message-mask-gradient-y: 90%;
            --glass-message-opacity: 0.6;
            transform-origin: 50% 50%;
            transform: scale3d(1.02, 1.02, 1);
            /* box-shadow: inset 0px 0px 0px rgba(85, 85, 85, 0), inset -10px -10px 10px rgba(85, 85, 85, 0.4); */
        }

        .message-content.sent.text:hover{
            --blend-bg-color: rgba(0, 0, 0, 0.25);
            --glass-message-opacity: 0;
            transform: none;
            /* box-shadow: inset 0px 0px 0px rgba(125, 125, 125, 0), inset 0px 0px 15px rgba(125, 125, 125, 0.4); */
        }

        .message-content-inner {
            position: relative;
            z-index: 1;
            opacity: 1;
            padding: 1.1rem 1.5rem; /* 12px 18px */
            transition: all 1.2s cubic-bezier(.41,.29,.18,1.26);
            border-radius: inherit;
            width: 100%;
        }

        .message-content.text .message-content-inner {
            color: #ffffff;
            /* line-height: 1.6; */
            text-shadow: 0 0 0.25rem rgba(0, 0, 0, 0.45);
            font-weight: 500;
        }

        .message-content.image .message-content-inner,
        .message-content.video .message-content-inner {
            padding: 0.6rem;
        }

        .message-content.image,
        .message-content.video{
            /* max-width: 60%; */
        }

        .message-content.image img,
        .message-content.video video {
            max-width: 100%;
            border-radius: 1.6rem;
            display: block;
            cursor: pointer;
            /* box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 0, 0.2); */
        }

        .message-content.audio .message-content-inner {
            width: 100%;
            padding: 0.75rem 1rem 0.85rem;
        }

        .audio-message {
            --audio-progress: 0%;
            display: flex;
            align-items: center;
            gap: 0.65rem;
            /* min-width: 20rem; */
            flex-wrap: nowrap;
        }

        .audio-message audio {
            display: none;
        }

        .audio-nav {
            width: 2.25rem;
            height: 2.25rem;
            border-radius: 50%;
            border: none;
            display: grid;
            place-items: center;
            /* background: rgba(255, 255, 255, 0.16); */
            /* box-shadow: 0 0.5rem 1.35rem rgba(0, 0, 0, 0.32); */
            transition: box-shadow 0.2s ease;
            cursor: pointer;
            padding: 0;
            flex-shrink: 0;
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.95);
            line-height: 1;
        }

        .audio-nav:hover:not(:disabled) {
            box-shadow: 0 0.9rem 1.85rem rgba(0, 0, 0, 0.4);
        }

        .audio-nav:focus-visible {
            /* outline: 2px solid rgba(255, 255, 255, 0.65);
            outline-offset: 3px; */
        }

        .audio-nav:disabled {
            opacity: 0.38;
            cursor: default;
            box-shadow: none;
        }

        .audio-button {
            width: 2.85rem;
            height: 2.85rem;
            border-radius: 50%;
            border: none;
            display: grid;
            place-items: center;
            /* background: linear-gradient(135deg, rgba(255, 255, 255, 0.38), rgba(255, 255, 255, 0.16)); */
            box-shadow: 0 0.75rem 1.75rem rgba(0, 0, 0, 0.35);
            transition: box-shadow 0.2s ease;
            cursor: pointer;
            padding: 0;
            flex-shrink: 0;
        }

        .audio-button:hover {
            /* box-shadow: 0 1.1rem 2.1rem rgba(0, 0, 0, 0.4); */
        }

        .audio-button:focus-visible {
            /* outline: 2px solid rgba(255, 255, 255, 0.65); */
            /* outline-offset: 3px; */
        }

        .audio-button-icon {
            position: relative;
            width: 1.1rem;
            height: 1.1rem;
        }

        .audio-button-icon::before {
            content: '';
            position: absolute;
            left: 0.25rem;
            top: 0.1rem;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0.45rem 0 0.45rem 0.8rem;
            border-color: transparent transparent transparent rgba(255, 255, 255, 0.96);
            transition: opacity 0.1s ease;
        }

        .audio-button-icon::after {
            content: '';
            position: absolute;
            top: 0.15rem;
            left: 0.25rem;
            width: 0.3rem;
            height: 0.8rem;
            background: rgba(255, 255, 255, 0.96);
            box-shadow: 0.38rem 0 0 0 rgba(255, 255, 255, 0.96);
            border-radius: 0.2rem;
            opacity: 0;
            /* transform: translateX(-0.2rem); */
            transition: opacity 0.1s ease, transform 0.1s ease;
        }

        .audio-button.is-playing {
            /* background: linear-gradient(135deg, rgba(99, 170, 255, 0.96), rgba(138, 109, 255, 0.92)); */
            /* box-shadow: 0 0.9rem 2.2rem rgba(32, 79, 255, 0.4); */
        }

        .audio-button.is-playing .audio-button-icon::before {
            opacity: 0;
        }

        .audio-button.is-playing .audio-button-icon::after {
            opacity: 1;
            transform: translateX(0);
        }

        .audio-waveform {
            position: relative;
            flex: 1;
            min-width: 5rem;
            height: 0.3rem;
            border-radius: 999px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.06);
        }

        .audio-waveform-base,
        .audio-waveform-progress {
            position: absolute;
            inset: 0;
            /* mask: repeating-linear-gradient(90deg, rgba(0, 0, 0, 0.95) 0 9px, transparent 9px 14px);
            -webkit-mask: repeating-linear-gradient(90deg, rgba(0, 0, 0, 0.95) 0 9px, transparent 9px 14px); */
        }

        .audio-waveform-base {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.22), rgba(255, 255, 255, 0.08));
            opacity: 0.75;
            transition: opacity 0.2s ease;
        }

        .audio-waveform-progress {
            width: 0%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.92), rgba(255, 255, 255, 0.58));
            transition: width 0.2s ease;
        }

        .audio-message.is-playing .audio-waveform-progress {
            transition: width 0.12s ease;
        }

        .audio-message.is-playing .audio-waveform-base {
            opacity: 1;
        }

        .audio-duration {
            font-size: 0.82rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 0.01em;
            font-variant-numeric: tabular-nums;
            min-width: 2.6rem;
            flex-shrink: 0;
            text-align: right;
        }

        .audio-message.is-playing .audio-duration {
            color: rgba(255, 255, 255, 0.95);
        }

        .audio-waveform,
        .audio-duration {
            cursor: pointer;
        }

        .audio-message:focus-visible {
            outline: 2px solid rgba(255, 255, 255, 0.45);
            outline-offset: 4px;
        }

        .audio-message:not(.is-playing) .audio-button:hover .audio-button-icon::before {
            opacity: 1;
        }

        /* Project Button in Chat */
        .message-content.project-button {
            padding: 0;
            border-radius: 1.5rem;
        }

        .message-content.project-button .message-content-inner {
            padding: 0.25rem; /* 4px */
        }

        .message-content.project-button img {
            width: 4.5rem; /* 72px */
            height: 4.5rem; /* 72px */
            object-fit: cover;
            /* filter: saturate(0.8) contrast(1.1); */
            opacity: 1;
            /* transition: all 0.3s; */
            /* border-radius: 0.875rem; */
            display: none;
        }

        .message-content.project-button:hover img {
            /* filter: saturate(1.2) contrast(1.2); */
            /* opacity: 1; */
        }


        .glass-surface.message-glass {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            /* pointer-events: none; */
        }

        .glass-surface.message-glass .glass-surface__content {
            display: block;
            width: 100%;
            height: 100%;
            padding: 0;
            /* pointer-events: auto; */
        }

        .glass-surface.button-glass,
        .glass-surface.typing-glass,
        .glass-surface.overlay-glass {
            width: 100%;
            height: 100%;
        }

        .glass-surface.button-glass,
        .glass-surface.typing-glass {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .glass-surface.button-glass .glass-surface__content,
        .glass-surface.typing-glass .glass-surface__content,
        .glass-surface.overlay-glass .glass-surface__content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .glass-surface.button-glass .glass-surface__content {
            padding: 0;
        }

        .glass-surface.typing-glass .glass-surface__content {
            padding: 0.75rem 1rem;
        }

        .glass-surface.overlay-glass {
            display: inline-flex;
        }

        .glass-surface.overlay-glass .glass-surface__content {
            padding: 0.35rem 0.75rem;
            justify-content: space-between;
        }

        /* Updated Typing Indicator with Glass Effect */
        .typing-indicator {
            display: none;
            align-items: center;
            margin: 0.94rem 0; /* 15px 0 */
            pointer-events: none;
            /* width: 100%; */
            max-width: 50rem; /* 800px */
            justify-content: center;
            opacity: 0;
        }

        .typing-indicator.active {
            opacity: 1;
            display: flex;
        }

        .typing-dots {
            position: relative;
            padding: 0;
            border-radius: 1.5rem; /* 18px */
            /* background: rgba(255, 255, 255, 0.05); */
            background: none;
            transition: all 1.5s ease, opacity 0.28s ease, transform 0.5s ease;
            opacity: 0;
            transform: scale3d(0,0,1);
            transform-origin: center bottom;
            /* box-shadow: inset 0 0 0.25rem 0 rgba(255, 255, 255, 0.3),
                        0 0.25rem 0.375rem rgba(0, 0, 0, 0.2),
                        0 0 0.9375rem rgba(0, 0, 0, 0.1); */
        }

        .typing-dots.active{
            opacity: 1;
            transform: scale3d(1,1,1);
        }

        .typing-dots-content {
            position: relative;
            z-index: 1;
            display: flex;
            gap: 0.25rem; /* 4px */
        }

        .typing-dots span {
            width: 0.5rem; /* 8px */
            height: 0.5rem; /* 8px */
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.75);
            transform: translate3d(0, 0.0625rem, 0); /* 1px */
            animation: typing 1.4s infinite;
            box-shadow: 0 0 0.25rem rgba(255, 255, 255, 0.3); /* 4px */
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translate3d(0, 1px, 0); /* 1px */
                opacity: 0.6;
            }
            30% {
                transform: translate3d(0, -3.5px, 0); /* -3.5px */
                opacity: 1;
            }
        }

        /* Media Overlay with enhanced opacity transition */
        .media-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
            backdrop-filter: blur(0);
            -webkit-backdrop-filter: blur(0);
            transition: background 0.4s ease, backdrop-filter 0.4s ease;
        }

        .media-overlay.active {
            display: flex;
            animation: overlayFadeIn 0.4s ease forwards;
        }

        .media-overlay.closing {
            animation: overlayFadeOut 0.4s ease forwards;
        }

        @keyframes overlayFadeIn {
            from {
                background: rgba(0, 0, 0, 0);
                backdrop-filter: blur(0);
                -webkit-backdrop-filter: blur(0);
            }
            to {
                background: rgba(0, 0, 0, 0.7);
                backdrop-filter: blur(0.63rem);
                -webkit-backdrop-filter: blur(0.63rem);
            }
        }

        @keyframes overlayFadeOut {
            from {
                background: rgba(0, 0, 0, 0.7);
                backdrop-filter: blur(0.63rem);
                -webkit-backdrop-filter: blur(0.63rem);
            }
            to {
                background: rgba(0, 0, 0, 0);
                backdrop-filter: blur(0);
                -webkit-backdrop-filter: blur(0);
            }
        }

        .media-overlay-content {
            max-width: 90%;
            max-height: 90%;
            position: relative;
            contain: paint;
            opacity: 0;
            transform: scale(0.95);
            animation: contentFadeIn 0.4s ease 0.1s forwards;
        }

        .media-overlay.closing .media-overlay-content {
            animation: contentFadeOut 0.3s ease forwards;
        }

        @keyframes contentFadeIn {
            to {
                opacity: 1;
            }
        }

        @keyframes contentFadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        .media-overlay img,
        .media-overlay video {
            max-width: 100%;
            max-height: 90vh;
            border-radius: 0.5rem; /* 8px */
            /* box-shadow: 0 1.25rem 3.75rem rgba(0, 0, 0, 0.8); */
        }

        /* Zoom-specific styles for desktop only */
        .media-overlay-content.zoom-enabled {
            overflow: hidden;
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .media-overlay-content.zoom-enabled img{
            cursor: grab;
        }

        .media-overlay-content.zoom-enabled.dragging img {
            cursor: grabbing;
            transition: none !important;
        }

        .media-overlay-content.zoom-enabled img {
            /* transition: transform 0.2s ease-in-out;
            transform-origin: center center; */
        }

        .close-button {
            position: absolute;
            top: 0.57rem; /* 9px */
            right: 0.38rem; /* 6px */
            width: 2.25rem; /* 36px */
            height: 2.25rem; /* 36px */
            display: flex;
            justify-content: center;
            align-items: top;
            cursor: pointer;
            transition: transform 0.3s;
            color: white;
            font-size: 1.57rem; /* 25px */
            opacity: 0;
            animation: contentFadeIn 0.4s ease 0.3s forwards;
            z-index: 10;
        }

        .media-overlay.closing .close-button {
            animation: contentFadeOut 0.2s ease forwards;
        }

        .close-button::after {
            content: '\2715'
        }

        .close-button:hover {
            transform: rotate(90deg);
        }

        /* Zoom controls for desktop */
        .zoom-controls {
            position: absolute;
            bottom: 1rem;
            left: 1.25rem;
            /* transform: translate3d(-50%,0,0); */
            display: none;
            gap: 0.5rem;
            background: none;
            padding: 0.4rem;
            padding-left: 0.7rem;
            padding-right: 0.7rem;
            border-radius: 2rem;
            z-index: 10;
        }

        .zoom-controls.visible {
            display: flex;
        }

        .zoom-controls button {
            width: 2rem;
            height: 2rem;
            border: none;
            background: none;
            color: rgb(200, 200, 200);
            /* border-radius: 0.25rem; */
            margin-top: -3px;
            cursor: pointer;
            font-size: 1.35rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.15s ease;
        }

        .zoom-controls button:hover {
            color: white;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .message-content {
                max-width: 85%;
            }
            
            .project-button {
                width: 3.125rem; /* 50px */
                height: 3.125rem; /* 50px */
            }

            .button-scroll-container {
                gap: 1.125rem; /* 18px */
            }
            
            .message-content video {
                max-width: 17.5rem; /* 280px */
            }
        }

        @media (max-width: 480px) {
            .chat-container {
                padding: 0.9375rem; /* 15px */
            }
            
            .message-content {
                max-width: 90%;
            }

            .button-scroll-container {
                gap: 0.875rem; /* 14px */
            }
        }
    </style>
</head>
<body>
    <!-- Ripple Grid Background -->
    <div id="rippleGridBackground"></div>

    <!-- Canvas Background -->
    <div class="text-canvas-wrapper">
        <canvas id="bgCanvas"></canvas>
    </div>

    <div class="bg-vignette"></div>
    

    <!-- Main Content -->
    <div class="main-wrapper">
        <div class="chat-container" id="chatContainer">
            <div class="chat-space-before"></div>
            <!-- Messages will appear here -->
            <div class="chat-space-after"></div>
        </div>

        <div class="typing-indicator" id="typingIndicator">
            <div class="typing-dots">
                <div class="typing-dots-content">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>

        <div class="button-section">
            <div class="button-scroll-container" id="buttonContainer">
                <!-- Project buttons will be generated here -->
            </div>
        </div>
    </div>

    <div class="media-overlay" id="mediaOverlay">
        <div class="close-button" onclick="closeMediaOverlay()"></div>
        <div class="media-overlay-content">
            <div id="overlayContent"></div>
            <div class="zoom-controls" id="zoomControls">
                <button onclick="zoomOut()">✢</button>
                <button onclick="resetZoom()">✼</button>
                <button onclick="zoomIn()">❋</button>
            </div>
        </div>
    </div>

    <script>
                // === GLASS SURFACE EFFECT INTEGRATION ===
        const qualityState = {
            mode: 'high',
            qualityMultiplier: 1,
            lastSwitch: performance.now()
        };
        const glassSurfaceSettings = {
            projectButton: {
                borderWidth: 0.07,
                backgroundOpacity: 0.07,
                blur: 12,
                displace: 2,
                distortionScale: -160,
                redOffset: 4,
                greenOffset: 12,
                blueOffset: 20,
                mixBlendMode: 'difference',
                getQualityMultiplier: () => (qualityState.mode === 'recovery' ? 0.7 : 1),
                maxFilterResolution: null,
                minFilterResolution: null
            },
            message: {
                base: {
                    borderWidth: 0.07,
                    backgroundOpacity: 0.07,
                    blur: 12,
                    displace: 2,
                    distortionScale: -150,
                    redOffset: 4,
                    greenOffset: 12,
                    blueOffset: 20,
                    mixBlendMode: 'difference',
                    maxFilterResolution: 800,
                    minFilterResolution: 650,
                    getQualityMultiplier: () => (qualityState.mode === 'recovery' ? 0.7 : 1)
                },
                mediaOverrides: {
                    borderWidth: 0.13,
                    maxFilterResolution: 300,
                    minFilterResolution: 200,
                    disableFilterAbove: 350
                }
            },
            typingIndicator: {
                borderWidth: 0.07,
                backgroundOpacity: 0.07,
                blur: 12,
                displace: 2,
                distortionScale: -150,
                redOffset: 4,
                greenOffset: 12,
                blueOffset: 20,
                mixBlendMode: 'screen',
                getQualityMultiplier: () => (qualityState.mode === 'recovery' ? 0.6 : 1),
                maxFilterResolution: null,
                minFilterResolution: null
            },
            zoomControls: {
                borderWidth: 0.07,
                backgroundOpacity: 0.1,
                blur: 9,
                displace: 0.45,
                distortionScale: -110,
                redOffset: 2,
                greenOffset: 8,
                blueOffset: 14,
                mixBlendMode: 'screen',
                getQualityMultiplier: () => (qualityState.mode === 'recovery' ? 0.7 : 1),
                maxFilterResolution: null,
                minFilterResolution: null
            }
        };
        const rippleGridSettings = {
            shared: {
                enableRainbow: false,
                gridColor: '#cde4ff',
                rippleIntensity: 0.07,
                gridSize: 8.6,
                gridThickness: 17.5,
                fadeDistance: 2,
                vignetteStrength: 2.5,
                glowIntensity: 0.5,
                opacity: 0.6,
                gridRotation: 0,
                curvatureAmount: 0.2,
                timeMultiplier: 1,
                autoRippleSpeed: 0.5,
                mouseInteractionRadius: 0.24,
                mouseRippleStrength: 0.95,
                maxDpr: 2,
                mouseLerp: 0.12,
                influenceLerp: 0.12
            },
            desktop: {
                autoRippleStrength: 0,
                mouseInteraction: true,
                rippleIntensity: 0.095,
                gridSize: 15,
                gridThickness: 35,
                fadeDistance: 1.7,
                vignetteStrength: 2.5,
                curvatureAmount: 0.3,
                autoRippleSpeed: 0.55,
                glowIntensity: 0.5,
                mouseRippleStrength: 0.5,
                mouseInteractionRadius: 0.35,
                mouseLerp: 0.15,
                influenceLerp: 0.18
            },
            mobile: {
                autoRippleStrength: 1,
                mouseInteraction: false,
                rippleIntensity: 0.055,
                gridSize: 7.8,
                gridThickness: 16.0,
                fadeDistance: 1.25,
                vignetteStrength: 1.6,
                curvatureAmount: 0.18,
                autoRippleSpeed: 0.75,
                glowIntensity: 0.26,
                timeMultiplier: 0.85,
                opacity: 0.9
            }
        };

        // Track readiness of background canvas and WebGL effects.
        function createEffectLoadTracker() {
            const componentNames = ['canvas', 'webgl'];
            const components = new Map();

            function createDeferred(name) {
                let resolved = false;
                let cachedDetail;
                let resolveFn = () => {};
                const promise = new Promise((resolve) => {
                    resolveFn = (detail) => {
                        if (resolved) {
                            return cachedDetail;
                        }
                        resolved = true;
                        cachedDetail = detail;
                        resolve(detail);
                        document.dispatchEvent(new CustomEvent('effects:component-ready', {
                            detail: { component: name, payload: detail }
                        }));
                        if (document.body) {
                            const dataKey = `effects${name.charAt(0).toUpperCase()}${name.slice(1)}Ready`;
                            document.body.dataset[dataKey] = 'true';
                        }
                        return cachedDetail;
                    };
                });

                return {
                    promise,
                    resolve(detail) {
                        return resolveFn(detail);
                    },
                    isResolved() {
                        return resolved;
                    },
                    getDetail() {
                        return cachedDetail;
                    }
                };
            }

            componentNames.forEach((name) => {
                components.set(name, createDeferred(name));
            });

            const readyPromise = Promise.all(componentNames.map((name) => components.get(name).promise))
                .then(([canvasDetail, webglDetail]) => {
                    const payload = { canvas: canvasDetail, webgl: webglDetail };
                    if (document.body) {
                        document.body.classList.add('effects-ready');
                        document.body.dataset.effectsReady = 'true';
                    }
                    document.dispatchEvent(new CustomEvent('effects:ready', { detail: payload }));
                    return payload;
                });

            return {
                signal(name, detail) {
                    if (!components.has(name)) {
                        console.warn(`[effects] Unknown component "${name}"`);
                        return;
                    }
                    components.get(name).resolve(detail);
                },
                isComponentReady(name) {
                    return components.has(name) ? components.get(name).isResolved() : false;
                },
                whenComponentReady(name) {
                    if (!components.has(name)) {
                        return Promise.reject(new Error(`Unknown effects component: ${name}`));
                    }
                    return components.get(name).promise;
                },
                whenReady() {
                    return readyPromise;
                },
                getComponentDetail(name) {
                    return components.has(name) ? components.get(name).getDetail() : null;
                }
            };
        }

        const effectLoadTracker = createEffectLoadTracker();
        window.effectsLoadTracker = effectLoadTracker;
        window.whenEffectsReady = () => effectLoadTracker.whenReady();
        window.whenEffectComponentReady = (name) => effectLoadTracker.whenComponentReady(name);

        const rippleGridState = {
            modulePromise: null,
            module: null,
            instance: null,
            destroyed: false,
            lastProfile: null
        };

        function getRippleGridProfileKey() {
            return isDesktop ? 'desktop' : 'mobile';
        }

        function buildRippleGridOptions() {
            const profileKey = getRippleGridProfileKey();
            const profile = rippleGridSettings[profileKey] || {};
            return { ...rippleGridSettings.shared, ...profile };
        }

        function ensureRippleGridModule() {
            if (!rippleGridState.modulePromise) {
                rippleGridState.modulePromise = import('./RippleGrid_WebGL/Grid.js')
                    .then((module) => {
                        rippleGridState.module = module;
                        return module;
                    })
                    .catch((error) => {
                        rippleGridState.modulePromise = null;
                        console.error('Failed to load ripple grid module', error);
                        throw error;
                    });
            }
            return rippleGridState.modulePromise;
        }

        function initOrUpdateRippleGrid() {
            if (rippleGridState.destroyed && rippleGridState.instance) {
                return;
            }
            rippleGridState.destroyed = false;
            const container = document.getElementById('rippleGridBackground');
            if (!container) {
                if (!effectLoadTracker.isComponentReady('webgl')) {
                    effectLoadTracker.signal('webgl', { error: new Error('Missing ripple grid container') });
                }
                return;
            }

            const profileKey = getRippleGridProfileKey();
            ensureRippleGridModule()
                .then((module) => {
                    if (rippleGridState.destroyed) {
                        return;
                    }
                    const options = buildRippleGridOptions();

                    if (typeof module.createRippleGrid !== 'function') {
                        const error = new Error('Ripple grid module is missing createRippleGrid');
                        console.error(error);
                        if (!effectLoadTracker.isComponentReady('webgl')) {
                            effectLoadTracker.signal('webgl', { error });
                        }
                        return;
                    }

                    let createdInstance = false;

                    if (!rippleGridState.instance) {
                        rippleGridState.instance = module.createRippleGrid({
                            container,
                            options
                        });
                        createdInstance = true;
                    } else {
                        rippleGridState.instance.update(options);
                    }

                    const schedule =
                        typeof window.requestAnimationFrame === 'function'
                            ? window.requestAnimationFrame.bind(window)
                            : (cb) => setTimeout(cb, 0);

                    if (createdInstance || !effectLoadTracker.isComponentReady('webgl')) {
                        schedule(() => {
                            if (!effectLoadTracker.isComponentReady('webgl')) {
                                effectLoadTracker.signal('webgl', {
                                    instance: rippleGridState.instance,
                                    module,
                                    options,
                                    profile: profileKey
                                });
                            }
                        });
                    }

                    rippleGridState.lastProfile = profileKey;
                })
                .catch((error) => {
                    console.error('Ripple grid initialization failed', error);
                    if (!effectLoadTracker.isComponentReady('webgl')) {
                        effectLoadTracker.signal('webgl', { error });
                    }
                });
        }

        function destroyRippleGrid() {
            rippleGridState.destroyed = true;
            if (rippleGridState.instance) {
                rippleGridState.instance.destroy();
                rippleGridState.instance = null;
            }
        }
        const fpsSamples = [];
        let fpsSum = 0;
        const MAX_FPS_SAMPLES = 80;
        const QUALITY_THRESHOLDS = {
            dropFps: 39,
            raiseFps: 47,
            dropDuration: 1600,
            raiseDuration: 1100
        };
        let lowFpsSince = null;
        let highFpsSince = null;
        let lastFpsSampleTime = performance.now();

        const GlassSurfaceFX = (() => {
            const svgNS = 'http://www.w3.org/2000/svg';
            const defaultOptions = {
                width: null,
                height: null,
                borderRadius: null,
                borderWidth: 0.07,
                brightness: 40,
                opacity: 0.93,
                blur: 11,
                displace: 0,
                saturation: 2.4,
                backgroundOpacity: 0,
                distortionScale: -180,
                redOffset: 0,
                greenOffset: 10,
                blueOffset: 20,
                xChannel: 'R',
                yChannel: 'G',
                mixBlendMode: 'difference',
                getQualityMultiplier: null,
                maxFilterResolution: null,
                minFilterResolution: null,
                disableFilterAbove: null
            };

            const surfaces = new WeakMap();
            const surfaceList = new Set();
            let idCounter = 0;

            const supportsSvgFilters = (() => {
                const ua = navigator.userAgent;
                const isWebkit = /Safari/.test(ua) && !/Chrome/.test(ua);
                const isFirefox = /Firefox/.test(ua);
                if (isWebkit || isFirefox) {
                    return false;
                }
                const testDiv = document.createElement('div');
                testDiv.style.backdropFilter = 'url(#glass-filter)';
                return testDiv.style.backdropFilter !== '';
            })();

            function createSvgStructure(ids) {
                const svg = document.createElementNS(svgNS, 'svg');
                svg.classList.add('glass-surface__filter');

                const defs = document.createElementNS(svgNS, 'defs');
                svg.appendChild(defs);

                const filter = document.createElementNS(svgNS, 'filter');
                filter.setAttribute('id', ids.filterId);
                filter.setAttribute('color-interpolation-filters', 'sRGB');
                filter.setAttribute('x', '0%');
                filter.setAttribute('y', '0%');
                filter.setAttribute('width', '100%');
                filter.setAttribute('height', '100%');
                defs.appendChild(filter);

                const feImage = document.createElementNS(svgNS, 'feImage');
                feImage.setAttribute('x', '0');
                feImage.setAttribute('y', '0');
                feImage.setAttribute('width', '100%');
                feImage.setAttribute('height', '100%');
                feImage.setAttribute('preserveAspectRatio', 'none');
                feImage.setAttribute('result', 'map');
                filter.appendChild(feImage);

                const redChannel = document.createElementNS(svgNS, 'feDisplacementMap');
                redChannel.setAttribute('in', 'SourceGraphic');
                redChannel.setAttribute('in2', 'map');
                redChannel.setAttribute('result', 'dispRed');
                filter.appendChild(redChannel);

                const redMatrix = document.createElementNS(svgNS, 'feColorMatrix');
                redMatrix.setAttribute('in', 'dispRed');
                redMatrix.setAttribute('type', 'matrix');
                redMatrix.setAttribute('values', '1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0');
                redMatrix.setAttribute('result', 'red');
                filter.appendChild(redMatrix);

                const greenChannel = document.createElementNS(svgNS, 'feDisplacementMap');
                greenChannel.setAttribute('in', 'SourceGraphic');
                greenChannel.setAttribute('in2', 'map');
                greenChannel.setAttribute('result', 'dispGreen');
                filter.appendChild(greenChannel);

                const greenMatrix = document.createElementNS(svgNS, 'feColorMatrix');
                greenMatrix.setAttribute('in', 'dispGreen');
                greenMatrix.setAttribute('type', 'matrix');
                greenMatrix.setAttribute('values', '0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0');
                greenMatrix.setAttribute('result', 'green');
                filter.appendChild(greenMatrix);

                const blueChannel = document.createElementNS(svgNS, 'feDisplacementMap');
                blueChannel.setAttribute('in', 'SourceGraphic');
                blueChannel.setAttribute('in2', 'map');
                blueChannel.setAttribute('result', 'dispBlue');
                filter.appendChild(blueChannel);

                const blueMatrix = document.createElementNS(svgNS, 'feColorMatrix');
                blueMatrix.setAttribute('in', 'dispBlue');
                blueMatrix.setAttribute('type', 'matrix');
                blueMatrix.setAttribute('values', '0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0');
                blueMatrix.setAttribute('result', 'blue');
                filter.appendChild(blueMatrix);

                const blendRG = document.createElementNS(svgNS, 'feBlend');
                blendRG.setAttribute('in', 'red');
                blendRG.setAttribute('in2', 'green');
                blendRG.setAttribute('mode', 'screen');
                blendRG.setAttribute('result', 'rg');
                filter.appendChild(blendRG);

                const blendRGB = document.createElementNS(svgNS, 'feBlend');
                blendRGB.setAttribute('in', 'rg');
                blendRGB.setAttribute('in2', 'blue');
                blendRGB.setAttribute('mode', 'screen');
                blendRGB.setAttribute('result', 'output');
                filter.appendChild(blendRGB);

                const gaussianBlur = document.createElementNS(svgNS, 'feGaussianBlur');
                gaussianBlur.setAttribute('in', 'output');
                gaussianBlur.setAttribute('stdDeviation', '0.7');
                filter.appendChild(gaussianBlur);

                return { svg, filter, feImage, redChannel, greenChannel, blueChannel, gaussianBlur };
            }

            function getRadiusPx(element) {
                if (!element) return 0;
                const style = window.getComputedStyle(element);
                const radius = style.borderTopLeftRadius || style.borderRadius || '0';
                const match = radius.match(/[\d.]+/);
                return match ? parseFloat(match[0]) : 0;
            }

            function buildDisplacementMap(width, height, radius, options, ids) {
                const safeRadius = Number.isFinite(radius) ? radius : 0;
                const edgeSize = Math.min(width, height) * (options.borderWidth * 0.5);
                const innerWidth = Math.max(width - edgeSize * 2, 0);
                const innerHeight = Math.max(height - edgeSize * 2, 0);

                const svgContent = `
      <svg viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="${ids.redGradId}" x1="100%" y1="0%" x2="0%" y2="0%">
            <stop offset="0%" stop-color="#0000"/>
            <stop offset="100%" stop-color="red"/>
          </linearGradient>
          <linearGradient id="${ids.blueGradId}" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" stop-color="#0000"/>
            <stop offset="100%" stop-color="blue"/>
          </linearGradient>
        </defs>
        <rect x="0" y="0" width="${width}" height="${height}" fill="black"></rect>
        <rect x="0" y="0" width="${width}" height="${height}" rx="${safeRadius}" fill="url(#${ids.redGradId})" />
        <rect x="0" y="0" width="${width}" height="${height}" rx="${safeRadius}" fill="url(#${ids.blueGradId})" style="mix-blend-mode: ${options.mixBlendMode}" />
        <rect x="${edgeSize}" y="${edgeSize}" width="${innerWidth}" height="${innerHeight}" rx="${Math.max(safeRadius - edgeSize, 0)}" fill="hsl(0 0% ${options.brightness}% / ${options.opacity})" style="filter:blur(${options.blur}px)" />
      </svg>
    `;
                return `data:image/svg+xml,${encodeURIComponent(svgContent)}`;
            }

            function markReady(state) {
                if (!state || state.isReady) {
                    return;
                }
                state.isReady = true;
                if (state.resolveReady) {
                    state.resolveReady();
                    state.resolveReady = null;
                }
            }

            function scheduleUpdate(state) {
                if (state.raf) {
                    cancelAnimationFrame(state.raf);
                }
                state.raf = requestAnimationFrame(() => {
                    updateSurface(state);
                    state.raf = null;
                });
            }

            function updateSurface(state) {
                if (!state.host.isConnected) {
                    state.pending = true;
                    return;
                }

                const rect = state.measureTarget.getBoundingClientRect();
                const width = Math.max(1, Math.round(rect.width * 10)/10);
                const height = Math.max(1, Math.round(rect.height * 10)/10);
                if (!width || !height) {
                    return;
                }

                const disableThreshold = Number.isFinite(state.options.disableFilterAbove)
                    ? state.options.disableFilterAbove
                    : null;

                if (disableThreshold && (width > disableThreshold || height > disableThreshold)) {
                    state.container.classList.remove('glass-surface--svg');
                    state.container.classList.add('glass-surface--fallback');
                    state.container.style.removeProperty('--filter-id');
                    state.container.style.removeProperty('--glass-frost');
                    state.container.style.removeProperty('--glass-saturation');
                    state.feImage.removeAttribute('href');
                    state.pending = false;
                    markReady(state);
                    return;
                }

                const radius = getRadiusPx(state.radiusSource);
                const qualityMultiplier = typeof state.options.getQualityMultiplier === 'function'
                    ? state.options.getQualityMultiplier()
                    : (qualityState.mode === 'recovery' ? qualityState.qualityMultiplier : 1);

                const adjustedOptions = {
                    ...state.options,
                    blur: Math.max(0, state.options.blur * (0.7 + 0.3 * qualityMultiplier)),
                    displace: state.options.displace * qualityMultiplier,
                    distortionScale: state.options.distortionScale * qualityMultiplier
                };

                const dpr = window.devicePixelRatio || 1;
                const maxResOption = Number.isFinite(state.options.maxFilterResolution) ? state.options.maxFilterResolution : null;
                const minResOption = Number.isFinite(state.options.minFilterResolution) ? state.options.minFilterResolution : null;
                const maxDimension = Math.max(width, height);
                let resolutionScale = 1;

                if (maxResOption && maxResOption > 0) {
                    const limit = maxResOption * dpr;
                    if (maxDimension > limit) {
                        resolutionScale = limit / maxDimension;
                    }
                }

                if (minResOption && minResOption > 0) {
                    const minLimit = minResOption * dpr;
                    const minScale = Math.min(1, minLimit / maxDimension);
                    resolutionScale = Math.max(resolutionScale, minScale);
                }

                const renderWidth = Math.max(1, Math.round(width * resolutionScale));
                const renderHeight = Math.max(1, Math.round(height * resolutionScale));
                const renderRadius = Math.max(0, radius * resolutionScale);

                if (state.filter) {
                    state.filter.setAttribute('filterRes', `${renderWidth} ${renderHeight}`);
                }

                const mapUrl = buildDisplacementMap(renderWidth, renderHeight, renderRadius, adjustedOptions, state.ids);
                state.feImage.setAttribute('href', mapUrl);

                [
                    { ref: state.redChannel, offset: state.options.redOffset },
                    { ref: state.greenChannel, offset: state.options.greenOffset },
                    { ref: state.blueChannel, offset: state.options.blueOffset }
                ].forEach(({ ref, offset }) => {
                    ref.setAttribute('scale', (adjustedOptions.distortionScale + offset).toString());
                    ref.setAttribute('xChannelSelector', state.options.xChannel);
                    ref.setAttribute('yChannelSelector', state.options.yChannel);
                });

                state.gaussianBlur.setAttribute('stdDeviation', Math.max(0, adjustedOptions.displace).toString());

                state.container.classList.remove('glass-surface--fallback');
                state.container.style.setProperty('--filter-id', `url(#${state.ids.filterId})`);
                state.container.style.setProperty('--glass-frost', state.options.backgroundOpacity);
                state.container.style.setProperty('--glass-saturation', state.options.saturation);
                state.container.style.borderRadius = `${radius}px`;

                state.container.classList.toggle('glass-surface--svg', supportsSvgFilters);
                state.container.classList.toggle('glass-surface--fallback', !supportsSvgFilters);

                state.pending = false;
                markReady(state);
            }

            function forceRefresh(host) {
                const state = surfaces.get(host);
                if (!state) {
                    return;
                }
                if (state.raf) {
                    cancelAnimationFrame(state.raf);
                    state.raf = null;
                }
                updateSurface(state);
            }

            function attach({
                host,
                contentElement = host,
                className = '',
                options = {},
                measureTarget,
                radiusSource
            }) {
                if (!host) return null;

                const existing = surfaces.get(host);
                if (existing) {
                    existing.options = { ...existing.options, ...options };
                    if (className) {
                        existing.container.classList.add(className);
                    }
                    scheduleUpdate(existing);
                    return existing;
                }

                const suffix = (++idCounter).toString(36);
                const ids = {
                    filterId: `glass-filter-${suffix}`,
                    redGradId: `glass-red-${suffix}`,
                    blueGradId: `glass-blue-${suffix}`
                };

                const { svg, filter, feImage, redChannel, greenChannel, blueChannel, gaussianBlur } = createSvgStructure(ids);

                const container = document.createElement('div');
                container.className = ['glass-surface', className].filter(Boolean).join(' ');
                container.style.width = '100%';
                container.style.height = '100%';

                container.appendChild(svg);

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'glass-surface__content';
                container.appendChild(contentWrapper);


                if (contentElement === host) {
                    while (host.firstChild) {
                        contentWrapper.appendChild(host.firstChild);
                    }
                    host.appendChild(container);
                } else {
                    const parent = contentElement.parentNode;
                    if (!parent) return null;
                    parent.insertBefore(container, contentElement);
                    contentWrapper.appendChild(contentElement);
                }

                //Add CSS styled highlight for message bubble with glass effect
                //constrct highlight and blend layers
                let highlightSubClass = '';
                if (host.classList.contains('project-button')){
                    highlightSubClass = 'buttons';
                }else if(host.classList.contains('message-content')){
                    highlightSubClass = 'messages';
                }else if(host.classList.contains('typing-dots')){
                    highlightSubClass = 'typings';
                }else if(host.classList.contains('zoom-controls')){
                    highlightSubClass = 'typings';
                }
                const highlightWrapper = document.createElement('div');
                highlightWrapper.className = `glass-highlight-wrapper ${highlightSubClass}`;
                const highlightInner = document.createElement('div');
                highlightInner.className = `glass-highlight ${highlightSubClass}`;
                const highlightTint = document.createElement('div');
                highlightTint.className = 'glass-highlight-tint';

                highlightWrapper.appendChild(highlightInner);
                highlightWrapper.appendChild(highlightTint);

                const blendOverlay = document.createElement('div');
                blendOverlay.className = 'glass-blend-overlay';

                container.insertBefore(highlightWrapper, contentWrapper);
                container.insertBefore(blendOverlay, contentWrapper);

                //
                let readyResolve;
                const readyPromise = new Promise((resolve) => {
                    readyResolve = resolve;
                });

                const state = {
                    host,
                    container,
                    contentWrapper,
                    contentElement,
                    ids,
                    options: { ...defaultOptions, ...options },
                    filter,
                    feImage,
                    redChannel,
                    greenChannel,
                    blueChannel,
                    gaussianBlur,
                    readyPromise,
                    resolveReady: readyResolve,
                    isReady: false,
                    measureTarget: measureTarget || container,
                    radiusSource: radiusSource || host,
                    observer: null,
                    raf: null,
                    pending: false
                };

                const observer = new ResizeObserver(() => scheduleUpdate(state));
                observer.observe(state.measureTarget);
                state.observer = observer;

                surfaces.set(host, state);
                surfaceList.add(state);

                scheduleUpdate(state);

                return state;
            }

            function refreshAll() {
                surfaceList.forEach((state) => scheduleUpdate(state));
            }

            return {
                attach,
                refreshAll,
                forceRefresh,
                supportsSvg: () => supportsSvgFilters
            };
        })();

        // === CANVAS BACKGROUND EFFECT ===

        const minFontSize = 5;  
        const maxFontSize = 180;
        const shrinkDelay = 1800;
        const shrinkDuration = 800;
        const shuffleInterval = 100;
        
        const sourceText = "There was a table set out under a tree in front of the house, and the March Hare and the Hatter were having tea at it: a Dormouse was sitting between them, fast asleep, and the other two were using it as a cushion, resting their elbows on it, and talking over its head. 'Very uncomfortable for the Dormouse,' thought Alice; 'only, as it's asleep, I suppose it doesn't mind.'";
        
        const keyboardChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/~`';
        
        // Canvas State
        let bgCanvas, bgCtx;
        let mouse = { x: 0, y: 0 };
        let lastPosition = { x: 0, y: 0 };
        let textIndex = 0;
        let letters = [];
        let isDrawing = false;
        let lastDrawTime = 0;
        let animationId = null;
        let lastCanvasRenderTime = 0;
        let canvasPixelRatio = 1;
        let canvasPauseCount = 0;
        let inactivityTimer = null;
        let canvasPauseStarted = null;
        const INACTIVITY_TIMEOUT = 4000;
        const CANVAS_TARGET_FPS = 30;
        const canvas_text_init_color = { value: 250, alpha: -0.05 };
        const canvas_text_target_color = { value: 120, alpha: 1 };
        const canvas_text_end_color = { value: 0, alpha: 0.9 };
        const canvas_text_color_transition_delay = 600;
        const canvas_text_shrink_delay = 200;

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function cloneCanvasColor(colorConfig) {
            return { value: colorConfig.value, alpha: colorConfig.alpha };
        }

        function interpolateCanvasColor(startColor, endColor, progress) {
            const t = clamp(typeof progress === 'number' ? progress : 0, 0, 1);
            return {
                value: startColor.value + (endColor.value - startColor.value) * t,
                alpha: startColor.alpha + (endColor.alpha - startColor.alpha) * t
            };
        }

        // Surprise letter system (rare occurrence)
        let letterCounter = 0;
        let nextSurpriseAt = 50 + Math.floor(Math.random() * 31); // Next surprise at 50-80 letters
        
        // Performance: ENHANCED pre-calculated shuffled chars (2.5x more variations)
        const shuffledCharsCache = new Array(25).fill(null).map(() => {
            return new Array(50).fill(null).map(() => 
                keyboardChars[Math.floor(Math.random() * keyboardChars.length)]
            );
        });
        
        class Letter {
            constructor(char, x, y, size, angle) {
                this.originalChar = char;
                this.currentChar = char;
                this.x = x;
                this.y = y;
                this.originalSize = size;
                this.currentSize = size;
                this.angle = angle;
                this.birthTime = Date.now();
                this.scale = 1;
                this.isShuffling = false;
                this.lastShuffleTime = 0;
                this.shuffleCacheIndex = Math.floor(Math.random() * 25);
                this.shuffleIndex = 0;
                this.currentColor = cloneCanvasColor(canvas_text_init_color);
            }

            update(currentTimestamp = Date.now()) {
                const age = currentTimestamp - this.birthTime;

                if (age <= shrinkDelay) {
                    const colorDelay = clamp(canvas_text_color_transition_delay, 0, shrinkDelay);

                    this.scale = 1;
                    this.currentSize = this.originalSize;

                    if (age <= colorDelay) {
                        this.currentColor = cloneCanvasColor(canvas_text_init_color);
                    } else {
                        const effectiveDuration = Math.max(shrinkDelay - colorDelay, 1);
                        const normalizedAge = (age - colorDelay) / effectiveDuration;
                        const colorProgress = clamp(normalizedAge, 0, 1);
                        this.currentColor = interpolateCanvasColor(
                            canvas_text_init_color,
                            canvas_text_target_color,
                            colorProgress
                        );
                    }

                    return false;
                }

                const shrinkAge = age - shrinkDelay;
                const shrinkHold = Math.max(canvas_text_shrink_delay, 0);

                if (shrinkAge <= shrinkHold) {
                    this.scale = 1;
                    this.currentSize = this.originalSize;
                    this.currentColor = cloneCanvasColor(canvas_text_target_color);
                    this.isShuffling = false;
                    return false;
                }

                if (!this.isShuffling || (currentTimestamp - this.lastShuffleTime) > shuffleInterval) {
                    this.isShuffling = true;
                    // Use pre-calculated shuffled characters for better performance
                    this.currentChar = shuffledCharsCache[this.shuffleCacheIndex][this.shuffleIndex % 50];
                    this.shuffleIndex++;
                    this.lastShuffleTime = currentTimestamp;
                }

                const effectiveShrinkAge = shrinkAge - shrinkHold;
                const shrinkProgress = shrinkDuration === 0 ? 1 : Math.min(effectiveShrinkAge / shrinkDuration, 1);

                this.scale = Math.max(0, 1 - shrinkProgress);
                this.currentSize = this.originalSize * this.scale;
                this.currentColor = interpolateCanvasColor(
                    canvas_text_target_color,
                    canvas_text_end_color,
                    shrinkProgress
                );

                return shrinkProgress >= 1;
            }

            draw(context) {
                if (this.scale <= 0.01) return; // Skip very small letters

                const color = this.currentColor || canvas_text_init_color;
                const gray = Math.round(clamp(color.value, 0, 255));
                const alpha = clamp(color.alpha, 0, 1);

                context.save();
                context.font = `${this.currentSize}px Georgia`;
                context.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${alpha})`;
                context.translate(this.x, this.y);
                context.rotate(this.angle);
                context.fillText(this.currentChar, 0, 0);
                context.restore();
            }
        }

        function initCanvas() {
            bgCanvas = document.getElementById('bgCanvas');
            if (!bgCanvas) {
                const error = new Error('Missing #bgCanvas element');
                console.error(error);
                if (!effectLoadTracker.isComponentReady('canvas')) {
                    effectLoadTracker.signal('canvas', { error });
                }
                return;
            }

            bgCtx = bgCanvas.getContext('2d', {
                alpha: true,
                desynchronized: true // Better performance for canvas updates
            });

            if (!bgCtx) {
                const error = new Error('Failed to acquire 2D context for background canvas');
                console.error(error);
                if (!effectLoadTracker.isComponentReady('canvas')) {
                    effectLoadTracker.signal('canvas', { error });
                }
                return;
            }

            resizeCanvas();

            if (!effectLoadTracker.isComponentReady('canvas')) {
                effectLoadTracker.signal('canvas', {
                    canvas: bgCanvas,
                    context: bgCtx,
                    pixelRatio: canvasPixelRatio,
                    size: {
                        width: bgCanvas.width,
                        height: bgCanvas.height,
                        cssWidth: bgCanvas.style.width,
                        cssHeight: bgCanvas.style.height
                    }
                });
            }

            document.addEventListener('mousemove', handleCanvasMouseMove, { passive: true });
            document.addEventListener('mouseenter', handleCanvasMouseEnter, { passive: true });
            document.addEventListener('mouseleave', handleCanvasMouseLeave, { passive: true });
            window.addEventListener('resize', resizeCanvas, { passive: true });
            document.addEventListener('visibilitychange', handleVisibilityChange);
        }
        
        function resizeCanvas(force = false) {
            if (typeof force !== 'boolean') {
                force = false;
            }

            if (!bgCanvas || !bgCtx) {
                return;
            }

            const dprCap = qualityState.mode === 'recovery' ? 1 : 1.5;
            const dpr = Math.min(window.devicePixelRatio || 1, dprCap);
            const width = window.innerWidth;
            const height = window.innerHeight;

            const targetWidth = Math.round(width * dpr);
            const targetHeight = Math.round(height * dpr);

            if (!force && canvasPixelRatio === dpr && bgCanvas.width === targetWidth && bgCanvas.height === targetHeight) {
                return;
            }

            canvasPixelRatio = dpr;
            bgCanvas.width = targetWidth;
            bgCanvas.height = targetHeight;

            bgCanvas.style.width = `${width}px`;
            bgCanvas.style.height = `${height}px`;

            bgCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function startCanvasAnimation() {
            if (canvasPauseCount > 0) {
                return;
            }
            if (animationId === null && letters.length > 0 && !document.hidden) {
                animationId = requestAnimationFrame(animateCanvas);
            }
        }

        function stopCanvasAnimation() {
            if (animationId !== null) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            lastCanvasRenderTime = 0;
        }

        function pauseCanvasDuringConversation() {
            if (canvasPauseCount === 0) {
                if (inactivityTimer) {
                    clearTimeout(inactivityTimer);
                    inactivityTimer = null;
                }
                isDrawing = false;
                stopCanvasAnimation();
                canvasPauseStarted = Date.now();
            }
            canvasPauseCount++;
        }

        function resumeCanvasAfterConversation() {
            if (canvasPauseCount === 0) {
                return;
            }
            canvasPauseCount--;
            if (canvasPauseCount === 0) {
                if (canvasPauseStarted) {
                    const pauseDuration = Date.now() - canvasPauseStarted;
                    letters.forEach(letter => {
                        letter.birthTime += pauseDuration;
                    });
                    canvasPauseStarted = null;
                }
                if (letters.length > 0 && !document.hidden) {
                    startCanvasAnimation();
                }
                resetCanvasInactivityTimer();
            }
        }

        function resetCanvasInactivityTimer() {
            if (canvasPauseCount > 0) {
                if (inactivityTimer) {
                    clearTimeout(inactivityTimer);
                    inactivityTimer = null;
                }
                return;
            }
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            inactivityTimer = setTimeout(() => {
                isDrawing = false;
                inactivityTimer = null;
            }, INACTIVITY_TIMEOUT);
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                stopCanvasAnimation();
            } else if (letters.length > 0 && canvasPauseCount === 0) {
                startCanvasAnimation();
            }
        }
        
        function handleCanvasMouseMove(e) {
            if (canvasPauseCount > 0) {
                return;
            }

            mouse.x = e.clientX;
            mouse.y = e.clientY;

            if (!isDrawing) {
                lastPosition.x = mouse.x;
                lastPosition.y = mouse.y;
                isDrawing = true;
            }

            drawCanvasText();
            resetCanvasInactivityTimer();
        }
        
        function handleCanvasMouseEnter(e) {
            if (canvasPauseCount > 0) {
                return;
            }
            isDrawing = true;
            lastPosition.x = e.clientX;
            lastPosition.y = e.clientY;
            resetCanvasInactivityTimer();
        }

        function handleCanvasMouseLeave() {
            isDrawing = false;
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
                inactivityTimer = null;
            }
        }
        
        function drawCanvasText() {
            if (!isDrawing || canvasPauseCount > 0) return;
            
            const currentTime = Date.now();
            const minDrawInterval = qualityState.mode === 'recovery' ? 16 : 10;
            if (currentTime - lastDrawTime < minDrawInterval) return; // Throttle drawing
            
            const dx = mouse.x - lastPosition.x;
            const dy = mouse.y - lastPosition.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > minFontSize) {
                let fontSize;
                
                // INCREMENT LETTER COUNTER
                letterCounter++;
                
                // CHECK FOR SURPRISE LETTER (RARE OCCURRENCE)
                let isSurpriseLetter = false;
                if (letterCounter >= nextSurpriseAt) {
                    // Calculate what the size SHOULD be based on speed
                    const normalizedDistance = Math.min(distance / 500, 1);
                    const expectedSize = minFontSize + (normalizedDistance * (maxFontSize - minFontSize));
                    
                    // Only apply surprise if expected size is small or large, not medium
                    if (expectedSize < 35 || expectedSize > 90) {
                        isSurpriseLetter = true;
                    }
                    
                    // Set next surprise far in the future
                    nextSurpriseAt = letterCounter + 50 + Math.floor(Math.random() * 31); // Next surprise in 50-80 letters
                }
                
                if (isSurpriseLetter) {
                    // SURPRISE LETTER - DRASTICALLY DIFFERENT SIZE
                    const normalizedDistance = Math.min(distance / 500, 1);
                    const expectedSize = minFontSize + (normalizedDistance * (maxFontSize - minFontSize));
                    
                    // Now do the opposite!
                    if (expectedSize < 35) {
                        // Expected small, make it big!
                        fontSize = 90 + Math.random() * 60; // 90-150
                    } else if (expectedSize > 90) {
                        // Expected big, make it small!
                        fontSize = minFontSize + Math.random() * 20; // 8-28
                    }
                } else {
                    // NORMAL LETTER - EVEN MORE GRADUAL SCALING FOR MEDIUM SPEEDS
                    
                    // Normalize distance to 0-1 range (increased to 600 for even more gradual growth)
                    const normalizedDistance = Math.min(distance / 600, 1);
                    
                    // Use an even gentler logarithmic curve
                    // Using smaller multiplier (2 instead of 3) for slower growth
                    const logCurve = Math.log2(normalizedDistance * 2 + 1) / Math.log2(3); // Results in 0 to 1
                    
                    // Apply a much gentler power curve (reduced from 1.2 to 1.1)
                    const curveWithAccel = Math.pow(logCurve, 1.1);
                    
                    // Additional dampening for medium speeds
                    let scaleFactor = curveWithAccel;
                    if (distance > 30 && distance < 200) {
                        // Medium speed - apply extra dampening
                        scaleFactor = scaleFactor * 0.7; // Reduce by 30%
                    }
                    
                    // Map to font size range with some randomness for variety
                    const randomFactor = 0.95 + Math.random()*1; // 95% to 105% (less variation)
                    fontSize = minFontSize + (scaleFactor * (maxFontSize - minFontSize) * randomFactor);
                    
                    // Special handling for very slow/fast movements
                    if (distance < 15) {
                        // Very slow movement - keep text quite small
                        fontSize = minFontSize + Math.random() * 6;
                    } else if (distance > 400) {
                        // Very fast movement - allow large sizes
                        fontSize = fontSize * (0.9 + Math.random() * 0.2);
                    }
                }
                
                // Ensure we stay within bounds
                fontSize = Math.max(minFontSize, Math.min(fontSize, maxFontSize));
                
                const angle = Math.atan2(dy, dx);
                const char = sourceText[textIndex % sourceText.length];
                
                const letter = new Letter(char, lastPosition.x, lastPosition.y, fontSize, angle);
                letters.push(letter);
                startCanvasAnimation();
                
                // Performance optimization: limit array size more aggressively
                const maxLetters = qualityState.mode === 'recovery' ? 190 : 270;
                if (letters.length > maxLetters) {
                    letters.splice(0, letters.length - maxLetters);
                }
                
                bgCtx.font = `${fontSize}px Georgia`;
                const stepSize = bgCtx.measureText(char).width;
                
                lastPosition.x += Math.cos(angle) * stepSize;
                lastPosition.y += Math.sin(angle) * stepSize;
                
                textIndex++;
                lastDrawTime = currentTime;
            }
        }
        
        function animateCanvas() {
            if (canvasPauseCount > 0) {
                animationId = null;
                return;
            }

            const now = performance.now();
            const targetFrameInterval = 1000 / CANVAS_TARGET_FPS; // canvas fps throttle cap

            if ((now - lastCanvasRenderTime) < targetFrameInterval) {
                animationId = requestAnimationFrame(animateCanvas);
                return;
            }

            lastCanvasRenderTime = now;

            if (!bgCanvas || !bgCtx) {
                animationId = null;
                return;
            }

            bgCtx.clearRect(0, 0, bgCanvas.width / canvasPixelRatio, bgCanvas.height / canvasPixelRatio);

            const renderTimestamp = Date.now();

            letters = letters.filter(letter => {
                const shouldRemove = letter.update(renderTimestamp);
                if (!shouldRemove) {
                    letter.draw(bgCtx);
                }
                return !shouldRemove;
            });

            if (letters.length > 0 && !document.hidden) {
                animationId = requestAnimationFrame(animateCanvas);
            } else {
                animationId = null;
            }
        }


        // === PRELOADING FUNCTIONS ===
        
        // Preload a single image
        function preloadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                
                const timeout = setTimeout(() => {
                    reject(new Error(`Image load timeout: ${src}`));
                }, 30000); // 30 second timeout
                
                img.onload = () => {
                    clearTimeout(timeout);
                    resolve(img);
                };
                
                img.onerror = () => {
                    clearTimeout(timeout);
                    reject(new Error(`Failed to load image: ${src}`));
                };
                
                img.src = src;
            });
        }
        
        // Preload video metadata
        function preloadVideoMetadata(src) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                
                const timeout = setTimeout(() => {
                    reject(new Error(`Video metadata load timeout: ${src}`));
                }, 30000); // 30 second timeout
                
                video.onloadedmetadata = () => {
                    clearTimeout(timeout);
                    resolve(video);
                };
                
                video.onerror = () => {
                    clearTimeout(timeout);
                    reject(new Error(`Failed to load video metadata: ${src}`));
                };
                
                video.preload = 'metadata';
                video.src = src;
            });
        }

        function preloadAudioMetadata(src) {
            return new Promise((resolve) => {
                const audio = new Audio();
                let settled = false;

                const finalize = () => {
                    if (settled) return;
                    settled = true;
                    audio.removeEventListener('loadedmetadata', finalize);
                    audio.removeEventListener('canplaythrough', finalize);
                    audio.removeEventListener('error', finalize);
                    audio.src = '';
                    resolve(audio);
                };

                audio.preload = 'auto';
                audio.addEventListener('loadedmetadata', finalize);
                audio.addEventListener('canplaythrough', finalize);
                audio.addEventListener('error', finalize);
                audio.src = src;
                audio.load();
            });
        }
        
        // Preload content based on type
        async function preloadContent(type, content) {
            try {
                if (type === 'image') {
                    const srcMatch = content.match(/src="([^"]+)"/);
                    if (srcMatch) {
                        const preloadImg = new Image();
                        preloadImg.decoding = 'async';
                        preloadImg.src = srcMatch[1];

                        if (typeof preloadImg.decode === 'function') {
                            try {
                                await preloadImg.decode();
                            } catch (err) {
                                await new Promise((resolve) => {
                                    preloadImg.addEventListener('load', resolve, { once: true });
                                    preloadImg.addEventListener('error', resolve, { once: true });
                                });
                            }
                        } else {
                            await new Promise((resolve) => {
                                preloadImg.addEventListener('load', resolve, { once: true });
                                preloadImg.addEventListener('error', resolve, { once: true });
                            });
                        }
                    }
                } else if (type === 'video') {
                    const srcMatch = content.match(/src="([^"]+)"/);
                    if (srcMatch) {
                        await preloadVideoMetadata(srcMatch[1]);
                    }
                } else if (type === 'audio') {
                    const srcMatch = content.match(/src="([^"]+)"/);
                    if (srcMatch) {
                        await preloadAudioMetadata(srcMatch[1]);
                    }
                }
            } catch (error) {
                console.warn(`Preload failed for ${type}:`, error);
                // Continue anyway - show content even if preload fails
            }
        }

        const videoPosterCache = new Map();

        async function ensureVideoPoster(videoSrc, suppliedPoster) {
            if (suppliedPoster) {
                return suppliedPoster;
            }
            if (!videoSrc) {
                return null;
            }
            if (videoPosterCache.has(videoSrc)) {
                return videoPosterCache.get(videoSrc) || null;
            }

            try {
                const generatedPoster = await generatePosterFromVideo(videoSrc);
                videoPosterCache.set(videoSrc, generatedPoster || '');
                return generatedPoster;
            } catch (error) {
                console.warn('Poster generation failed:', error);
                videoPosterCache.set(videoSrc, '');
                return null;
            }
        }

        async function generatePosterFromVideo(videoSrc) {
            if (!videoSrc) {
                return null;
            }

            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                let settled = false;

                const cleanup = () => {
                    video.pause();
                    video.removeAttribute('src');
                    video.load();
                };

                const fail = (error) => {
                    if (settled) return;
                    settled = true;
                    cleanup();
                    reject(error);
                };

                const handleLoadedData = () => {
                    try {
                        if (!video.videoWidth || !video.videoHeight) {
                            throw new Error('Video dimensions unavailable');
                        }

                        const maxDimension = 1280;
                        const scale = Math.min(1, maxDimension / Math.max(video.videoWidth, video.videoHeight));
                        const width = Math.round(video.videoWidth * scale) || video.videoWidth;
                        const height = Math.round(video.videoHeight * scale) || video.videoHeight;

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const context = canvas.getContext('2d');

                        context.drawImage(video, 0, 0, width, height);

                        const maxBytes = 100 * 1024;
                        let quality = 0.85;
                        const minQuality = 0.45;

                        const estimateBytes = (dataUrl) => {
                            const base64 = dataUrl.split(',')[1] || '';
                            return Math.ceil(base64.length * 0.75);
                        };

                        let dataUrl = canvas.toDataURL('image/jpeg', quality);
                        while (estimateBytes(dataUrl) > maxBytes && quality > minQuality) {
                            quality = Math.max(minQuality, quality - 0.1);
                            dataUrl = canvas.toDataURL('image/jpeg', quality);
                        }

                        settled = true;
                        cleanup();
                        resolve(dataUrl);
                    } catch (generationError) {
                        fail(generationError);
                    }
                };

                video.addEventListener('loadeddata', handleLoadedData, { once: true });
                video.addEventListener('error', () => fail(new Error(`Failed to load video for poster: ${videoSrc}`)), { once: true });

                try {
                    video.crossOrigin = 'anonymous';
                } catch (crossOriginError) {
                    // Ignore if crossOrigin cannot be set
                }
                video.muted = true;
                video.preload = 'auto';
                video.src = videoSrc;
                video.load();
            });
        }

// === CHAT INTERFACE LOGIC ===
        // === VIDEO PLAYBACK COORDINATION ===
        const managedVideos = new Set();
        let currentPlayingVideo = null;
        let videoVisibilityObserver = null;

        const managedAudios = new Set();
        let currentPlayingAudio = null;

        function ensureVideoObserver() {
            if (!videoVisibilityObserver && typeof IntersectionObserver !== 'undefined') {
                videoVisibilityObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const video = entry.target;
                        if (!entry.isIntersecting && !video.paused && !video.ended) {
                            video.pause();
                        }
                    });
                }, {
                    root: null,
                    threshold: 0.1
                });
            }
            return videoVisibilityObserver;
        }

        function registerVideoElement(video) {
            if (!video || managedVideos.has(video)) return;
            managedVideos.add(video);

            video.addEventListener('play', handleManagedVideoPlay);
            video.addEventListener('pause', handleManagedVideoPause);
            video.addEventListener('ended', handleManagedVideoEnded);

            const observer = ensureVideoObserver();
            if (observer) {
                observer.observe(video);
            }

            if (!video.paused && !video.ended) {
                handleManagedVideoPlay({ currentTarget: video });
            }
        }

        function deregisterVideoElement(video) {
            if (!video || !managedVideos.has(video)) return;
            managedVideos.delete(video);

            video.removeEventListener('play', handleManagedVideoPlay);
            video.removeEventListener('pause', handleManagedVideoPause);
            video.removeEventListener('ended', handleManagedVideoEnded);

            if (videoVisibilityObserver) {
                videoVisibilityObserver.unobserve(video);
            }

            if (currentPlayingVideo === video) {
                currentPlayingVideo = null;
            }
        }

        function handleManagedVideoPlay(event) {
            const video = event && event.currentTarget ? event.currentTarget : event;
            if (!video) return;
            pauseAllManagedVideos(video);
            pauseAllManagedAudios();
            currentPlayingVideo = video;
        }

        function handleManagedVideoPause(event) {
            const video = event && event.currentTarget ? event.currentTarget : event;
            if (!video) return;
            if (currentPlayingVideo === video && (video.paused || video.ended)) {
                currentPlayingVideo = null;
            }
        }
        function handleManagedVideoEnded(event) {
            const video = event && event.currentTarget ? event.currentTarget : event;
            if (!video) return;
            if (currentPlayingVideo === video) {
                currentPlayingVideo = null;
            }
        }

        function pauseAllManagedVideos(except = null) {
            managedVideos.forEach((video) => {
                if (video !== except && !video.paused) {
                    video.pause();
                }
            });
        }

        function pauseAllManagedAudios(except = null) {
            managedAudios.forEach((audio) => {
                if (audio !== except && !audio.paused) {
                    audio.pause();
                }
            });
        }

        function formatAudioTime(seconds) {
            if (!isFinite(seconds) || seconds <= 0) {
                return '0:00';
            }
            const totalSeconds = Math.max(0, Math.floor(seconds));
            const minutes = Math.floor(totalSeconds / 60);
            const remainder = totalSeconds % 60;
            return `${minutes}:${remainder.toString().padStart(2, '0')}`;
        }

        function registerAudioMessage(container) {
            if (!container) return;
            const audio = container.querySelector('audio');
            if (!audio || managedAudios.has(audio)) return;

            const playButton = container.querySelector('.audio-button');
            const durationLabel = container.querySelector('.audio-duration');
            const progressBar = container.querySelector('.audio-waveform-progress');
            const prevButton = container.querySelector('.audio-nav.audio-prev');
            const nextButton = container.querySelector('.audio-nav.audio-next');

            let tracks = [];
            const tracksAttr = container.getAttribute('data-audio-tracks');
            if (tracksAttr) {
                try {
                    const parsed = JSON.parse(tracksAttr);
                    if (Array.isArray(parsed)) {
                        tracks = parsed
                            .map(src => (typeof src === 'string' ? src.trim() : ''))
                            .filter(src => src.length > 0);
                    }
                } catch (err) {
                    tracks = [];
                }
            }

            if (!tracks.length) {
                const fallbackSrc = audio.getAttribute('src') || audio.src || '';
                if (fallbackSrc) {
                    tracks = [fallbackSrc];
                }
            }

            let currentIndex = Number.parseInt(container.dataset.audioIndex, 10);
            if (!Number.isFinite(currentIndex)) {
                currentIndex = 0;
            }
            currentIndex = Math.max(0, Math.min(currentIndex, Math.max(0, tracks.length - 1)));
            container.dataset.audioIndex = String(currentIndex);

            const assignAudioSource = (src, { reload = false } = {}) => {
                if (!src) return;
                const currentAttr = audio.getAttribute('src') || '';
                let shouldReload = reload;
                if (currentAttr !== src) {
                    audio.setAttribute('src', src);
                    shouldReload = true;
                }
                if (shouldReload) {
                    audio.load();
                }
            };

            assignAudioSource(tracks[currentIndex] || '', { reload: false });

            const updateNavState = () => {
                const total = tracks.length;
                const hasMultipleTracks = total > 1;
                container.classList.toggle('has-multiple-tracks', hasMultipleTracks);
                container.classList.toggle('single-track', !hasMultipleTracks);

                const baseLabel = container.dataset.audioLabel || 'Audio message';
                if (hasMultipleTracks) {
                    container.setAttribute('aria-label', `${baseLabel} (${currentIndex + 1} of ${total})`);
                } else {
                    container.setAttribute('aria-label', baseLabel);
                }

                if (prevButton) {
                    const canNavigate = hasMultipleTracks;
                    prevButton.disabled = !canNavigate;
                    prevButton.setAttribute(
                        'aria-label',
                        canNavigate
                            ? `Previous audio (${((currentIndex - 1 + total) % total) + 1} of ${total})`
                            : 'Previous audio message'
                    );
                }

                if (nextButton) {
                    const canNavigate = hasMultipleTracks;
                    nextButton.disabled = !canNavigate;
                    nextButton.setAttribute(
                        'aria-label',
                        canNavigate
                            ? `Next audio (${((currentIndex + 1) % total) + 1} of ${total})`
                            : 'Next audio message'
                    );
                }
            };

            managedAudios.add(audio);

            const setPlayingState = (isPlaying) => {
                container.classList.toggle('is-playing', isPlaying);
                if (playButton) {
                    playButton.classList.toggle('is-playing', isPlaying);
                }
            };

            const updateDurationLabel = () => {
                if (!durationLabel) return;
                if (isFinite(audio.duration) && audio.duration > 0) {
                    const timeValue = audio.paused ? audio.duration : Math.max(audio.duration - audio.currentTime, 0);
                    durationLabel.textContent = formatAudioTime(timeValue);
                } else if (audio.currentTime > 0 && !isFinite(audio.duration)) {
                    durationLabel.textContent = formatAudioTime(audio.currentTime);
                } else {
                    durationLabel.textContent = '0:00';
                }
            };

            const updateProgress = () => {
                if (!progressBar) return;
                if (!isFinite(audio.duration) || audio.duration === 0) {
                    progressBar.style.width = '0%';
                    return;
                }
                const ratio = Math.min(1, Math.max(0, audio.currentTime / audio.duration));
                progressBar.style.width = `${(ratio * 100).toFixed(2)}%`;
            };

            const resetProgress = () => {
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
            };

            const handlePlay = () => {
                pauseAllManagedAudios(audio);
                pauseAllManagedVideos();
                currentPlayingAudio = audio;
                setPlayingState(true);
                updateDurationLabel();
            };

            const handlePause = () => {
                if (currentPlayingAudio === audio && (audio.paused || audio.ended)) {
                    currentPlayingAudio = null;
                }
                setPlayingState(false);
                updateDurationLabel();
            };

            const handleEnded = () => {
                audio.currentTime = 0;
                updateProgress();
                handlePause();
            };

            const handleTimeUpdate = () => {
                updateProgress();
                updateDurationLabel();
            };

            const handleLoadedMetadata = () => {
                resetProgress();
                updateDurationLabel();
                updateNavState();
            };

            const setTrack = (nextIndex, { autoplay = null, force = false } = {}) => {
                const total = tracks.length;
                if (!total) {
                    return;
                }
                let targetIndex = ((nextIndex % total) + total) % total;
                if (!force && targetIndex === currentIndex) {
                    return;
                }

                const wasPlaying = autoplay === null ? (!audio.paused && !audio.ended) : autoplay;

                audio.pause();
                audio.currentTime = 0;
                resetProgress();

                currentIndex = targetIndex;
                container.dataset.audioIndex = String(currentIndex);
                assignAudioSource(tracks[currentIndex] || '', { reload: true });
                updateNavState();
                updateDurationLabel();

                if (wasPlaying) {
                    pauseAllManagedAudios(audio);
                    const playPromise = audio.play();
                    if (playPromise && typeof playPromise.then === 'function') {
                        playPromise.catch(() => {
                            handlePause();
                        });
                    }
                }
            };

            const togglePlayback = () => {
                if (audio.paused || audio.ended) {
                    const playPromise = audio.play();
                    if (playPromise && typeof playPromise.then === 'function') {
                        playPromise.catch(() => {
                            handlePause();
                        });
                    }
                } else {
                    audio.pause();
                }
            };

            audio.addEventListener('loadedmetadata', handleLoadedMetadata);
            audio.addEventListener('play', handlePlay);
            audio.addEventListener('pause', handlePause);
            audio.addEventListener('ended', handleEnded);
            audio.addEventListener('timeupdate', handleTimeUpdate);

            if (playButton) {
                playButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    togglePlayback();
                });
            }

            if (prevButton) {
                prevButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    setTrack(currentIndex - 1);
                });
            }

            if (nextButton) {
                nextButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    setTrack(currentIndex + 1);
                });
            }

            container.addEventListener('click', (event) => {
                if ((playButton && playButton.contains(event.target)) ||
                    (prevButton && prevButton.contains(event.target)) ||
                    (nextButton && nextButton.contains(event.target))) {
                    return;
                }
                if (event.target.closest('.audio-waveform') || event.target.classList.contains('audio-duration') || event.target === container) {
                    togglePlayback();
                }
            });

            container.addEventListener('keydown', (event) => {
                if (event.key === ' ' || event.key === 'Enter') {
                    event.preventDefault();
                    togglePlayback();
                } else if (event.key === 'ArrowLeft') {
                    event.preventDefault();
                    setTrack(currentIndex - 1, { autoplay: !audio.paused && !audio.ended });
                } else if (event.key === 'ArrowRight') {
                    event.preventDefault();
                    setTrack(currentIndex + 1, { autoplay: !audio.paused && !audio.ended });
                }
            });

            updateNavState();
            resetProgress();
            updateDurationLabel();
        }
        
        // Cache DOM reference for better performance
        let cachedChatContainer = null;
        
        // Get or cache the chat container
        function getChatContainer() {
            if (!cachedChatContainer) {
                cachedChatContainer = document.getElementById('chatContainer');
            }
            return cachedChatContainer;
        }
        
        // Conversation lock to prevent multiple projects from mixing
        let isConversationInProgress = false;
        const messageTranslateOffset = 0.12 * window.innerWidth;
        // let firstProjectShow = true;

        // Updated projects structure with preview and full images
        const projects = [
            [
                {
                    id: 1,
                    buttonImage: '',
                    title: 'Digital Dreams',
                    description: 'An exploration of consciousness through algorithmic art. This project combines generative design with human emotion to create unique visual experiences.',
                    previewImages: [
                        'https://via.placeholder.com/400x267/4a90e2/ffffff?text=Preview+1',
                        'https://via.placeholder.com/400x267/e24a90/ffffff?text=Preview+2'
                    ],
                    fullImages: [
                        'https://via.placeholder.com/600x400/4a90e2/ffffff?text=Artwork+1',
                        'https://via.placeholder.com/600x400/e24a90/ffffff?text=Artwork+2'
                    ],
                    videos: ['https://www.w3schools.com/html/mov_bbb.mp4'],
                    audios: [
                        'https://www.w3schools.com/html/horse.mp3',
                        'https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3'
                    ]
                }
            ],
            [
                {
                    id: 2,
                    buttonImage: '',
                    title: 'Urban Fragments',
                    description: 'Capturing the essence of modern city life through fragmented perspectives and layered compositions.',
                    previewImages: [
                        'https://via.placeholder.com/400x267/90e24a/ffffff?text=Urban+Preview'
                    ],
                    fullImages: [
                        'https://via.placeholder.com/600x400/90e24a/ffffff?text=Urban+1'
                    ],
                    videos: []
                }
            ],
            [
                {
                    id: 3,
                    buttonImage: '',
                    title: 'Synthetic Nature',
                    description: 'Where organic meets digital. A series exploring the boundaries between natural and artificial.',
                    previewImages: [
                        'https://via.placeholder.com/400x267/4ae290/ffffff?text=Nature+Preview+1',
                        'https://via.placeholder.com/400x267/e2904a/ffffff?text=Nature+Preview+2'
                    ],
                    fullImages: [
                        'https://via.placeholder.com/600x400/4ae290/ffffff?text=Nature+1',
                        'https://via.placeholder.com/600x400/e2904a/ffffff?text=Nature+2'
                    ],
                    videos: ['https://www.w3schools.com/html/mov_bbb.mp4']
                }
            ],
            [
                {
                    id: 4,
                    buttonImage: '',
                    title: 'Memory Traces',
                    description: 'An investigation into collective memory and forgotten histories through mixed media installations.',
                    previewImages: ['https://via.placeholder.com/400x267/904ae2/ffffff?text=Memory+Preview'],
                    fullImages: ['https://via.placeholder.com/600x400/904ae2/ffffff?text=Memory+1'],
                    videos: []
                }
            ],
            [
                {
                    id: 5,
                    buttonImage: '',
                    title: 'Quantum Narratives',
                    description: 'Stories that exist in multiple states simultaneously, exploring parallel realities and possibilities.',
                    previewImages: ['https://via.placeholder.com/400x267/4a4a4a/ffffff?text=Quantum+Preview'],
                    fullImages: ['https://via.placeholder.com/600x400/4a4a4a/ffffff?text=Quantum+1'],
                    videos: []
                }
            ],
            [
                {
                    id: 6,
                    buttonImage: '',
                    title: 'Echo Chamber',
                    description: 'A sonic and visual journey through repeated patterns and recursive feedback loops.',
                    previewImages: ['https://via.placeholder.com/400x267/e24a4a/ffffff?text=Echo+Preview'],
                    fullImages: ['https://via.placeholder.com/600x400/e24a4a/ffffff?text=Echo+1'],
                    videos: ['https://www.w3schools.com/html/mov_bbb.mp4']
                }
            ],
            [
                {
                    id: 7,
                    buttonImage: '',
                    title: 'Liminal Spaces',
                    description: 'Exploring threshold moments and transitional states in human experience.',
                    previewImages: ['https://via.placeholder.com/400x267/4ae24a/ffffff?text=Liminal+Preview'],
                    fullImages: ['https://via.placeholder.com/600x400/4ae24a/ffffff?text=Liminal+1'],
                    videos: []
                }
            ],
            [
                {
                    id: 8,
                    buttonImage: '',
                    title: 'Data Sculptures',
                    description: 'Transforming information flows into tangible forms and immersive environments.',
                    previewImages: ['https://via.placeholder.com/400x267/e2e24a/ffffff?text=Data+Preview'],
                    fullImages: ['https://via.placeholder.com/600x400/e2e24a/ffffff?text=Data+1'],
                    videos: []
                }
            ],
            [
                {
                    id: 9,
                    buttonImage: '',
                    title: 'Temporal Drift',
                    description: 'Lorem ipsum dolor sit amet consectetur adipiscing elit. Quisque faucibus ex sapien vitae pellentesque sem placerat. In id cursus mi pretium tellus duis convallis. Tempus leo eu aenean sed diam urna tempor. Pulvinar vivamus fringilla lacus nec metus bibendum egestas. Iaculis massa nisl malesuada lacinia integer nunc posuere. Ut hendrerit semper vel class aptent taciti sociosqu. Ad litora torquent per conubia nostra inceptos himenaeos.',
                    previewImages: ['https://static.wixstatic.com/media/08c926_f27a7457431b40cb85be03be20c414c5~mv2.jpg/v1/fill/w_400,h_267,al_c,q_80/08c926_f27a7457431b40cb85be03be20c414c5~mv2.webp'],
                    fullImages: ['https://static.wixstatic.com/media/08c926_f27a7457431b40cb85be03be20c414c5~mv2.jpg'],
                    videos: ['https://video.wixstatic.com/video/08c926_cfd08b756c8c45faaa3b1c20394f4a21/1080p/mp4/file.mp4'],
                    videoPosters: []
                }
            ]
        ];

        // Initialize buttons
        function initializeButtons() {
            const buttonContainer = document.getElementById('buttonContainer');
            projects.forEach((projectEntries, index) => {
                if (!Array.isArray(projectEntries) || projectEntries.length === 0) {
                    return;
                }

                const representativeEntry =
                    projectEntries.find(entry => entry && typeof entry === 'object' && entry.buttonImage) ||
                    projectEntries.find(entry => entry && typeof entry === 'object') ||
                    null;

                if (!representativeEntry) {
                    return;
                }

                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'project-button disabled';
                button.onclick = () => showProject(projectEntries);

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'project-button-content';
                const img = document.createElement('img');
                img.src = representativeEntry.buttonImage || '';

                const titleIsValid = typeof representativeEntry.title === 'string' && representativeEntry.title.trim() !== '';
                const fallbackAlt = representativeEntry.id !== undefined && representativeEntry.id !== null
                    ? `Project ${representativeEntry.id}`
                    : `Project ${index + 1}`;
                img.alt = titleIsValid ? representativeEntry.title : fallbackAlt;

                contentWrapper.appendChild(img);

                button.appendChild(contentWrapper);

                const buttonWrapper = document.createElement('div');
                buttonWrapper.className = 'button-wrapper';
                buttonWrapper.appendChild(button);

                buttonContainer.appendChild(buttonWrapper);

                requestAnimationFrame(() => {
                    GlassSurfaceFX.attach({
                        host: button,
                        contentElement: contentWrapper,
                        className: 'button-glass',
                        options: { ...glassSurfaceSettings.projectButton }
                    });
                });
            });
        }

        // Show project in chat with improved timing
        async function showProject(projectEntries) {
            if (isConversationInProgress) {
                return;
            }

            if (!Array.isArray(projectEntries) || projectEntries.length === 0) {
                return;
            }

            const validEntries = projectEntries.filter(entry => entry && typeof entry === 'object');
            if (validEntries.length === 0) {
                return;
            }

            isConversationInProgress = true;

            mannualScrollOn = false;

            const buttons = document.querySelectorAll('.project-button');
            buttons.forEach(btn => btn.classList.add('disabled'));

            const chatContainer = getChatContainer();

            pauseCanvasDuringConversation();
            pauseAllManagedVideos();
            pauseAllManagedAudios();
            let resumeScheduled = false;
            const resumeAfterReveal = () => {
                if (!resumeScheduled) {
                    resumeScheduled = true;
                    resumeCanvasAfterConversation();
                }
            };

            try {
                requestAnimationFrame(() => {
                    document.querySelectorAll('.message.bot').forEach(mb => {
                        mb.style.transform = `translate3d(${getTranslationLimits(mb.firstElementChild, chatContainer, 'left') + messageTranslateOffset}px, 0, 0)`;
                    });
                    document.querySelectorAll('.message.user').forEach(mu => {
                        mu.style.transform = `translate3d(${getTranslationLimits(mu.firstElementChild, chatContainer, 'right') - messageTranslateOffset}px, 0, 0)`;
                    });
                });

                const sanitizeAttribute = (value) => {
                    if (typeof value !== 'string') {
                        return '';
                    }
                    return value
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                };

                const projectMessageContentElements = [];

                const representativeEntry = validEntries.find(entry => entry.buttonImage) || validEntries[0];
                if (representativeEntry) {
                    const hasTitle = typeof representativeEntry.title === 'string' && representativeEntry.title.trim() !== '';
                    const buttonAlt = hasTitle
                        ? representativeEntry.title
                        : (representativeEntry.id !== undefined && representativeEntry.id !== null
                            ? `Project ${representativeEntry.id}`
                            : 'Selected project');

                    projectMessageContentElements.push(
                        await addMessageWithParallelTiming(
                            'user',
                            'project-button',
                            `<img src="${representativeEntry.buttonImage || ''}" alt="${sanitizeAttribute(buttonAlt)}" loading="lazy" decoding="async">`
                        )
                    );
                }

                for (const entry of validEntries) {
                    const entryHasTitle = typeof entry.title === 'string' && entry.title.trim() !== '';
                    if (entryHasTitle) {
                        projectMessageContentElements.push(
                            await addMessageWithParallelTiming('bot', 'text', `<strong>${entry.title}</strong>`)
                        );
                    }

                    const entryHasDescription = typeof entry.description === 'string' && entry.description.trim() !== '';
                    if (entryHasDescription) {
                        projectMessageContentElements.push(
                            await addMessageWithParallelTiming('bot', 'text', entry.description)
                        );
                    }

                    const previewImages = Array.isArray(entry.previewImages) ? entry.previewImages : [];
                    const fullImages = Array.isArray(entry.fullImages) ? entry.fullImages : [];

                    for (let i = 0; i < previewImages.length; i++) {
                        const previewSrc = previewImages[i];
                        const fullSrc = fullImages[i] || previewSrc;
                        projectMessageContentElements.push(
                            await addMessageWithParallelTiming(
                                'bot',
                                'image',
                                `<img src="${previewSrc}" alt="${sanitizeAttribute(entry.title || '')}" data-full-src="${fullSrc}" loading="lazy" decoding="async" onclick="openMediaOverlay('image', '${fullSrc}', event)">`
                            )
                        );
                    }

                    const videos = Array.isArray(entry.videos) ? entry.videos : [];
                    const videoPosters = Array.isArray(entry.videoPosters) ? entry.videoPosters : [];

                    for (let i = 0; i < videos.length; i++) {
                        const videoSrc = videos[i];
                        const manualPoster = videoPosters[i];
                        const poster = await ensureVideoPoster(videoSrc, manualPoster);
                        const posterAttribute = poster ? ` poster="${poster}"` : '';
                        projectMessageContentElements.push(
                            await addMessageWithParallelTiming(
                                'bot',
                                'video',
                                `<video src="${videoSrc}" controls preload="metadata" playsinline${posterAttribute} onclick="openMediaOverlay('video', '${videoSrc}', event)"></video>`
                            )
                        );
                    }

                    const audios = Array.isArray(entry.audios) ? entry.audios : [];
                    const validAudioSources = audios
                        .map(src => (typeof src === 'string' ? src.trim() : ''))
                        .filter(src => src.length > 0);

                    if (validAudioSources.length > 0) {
                        const sanitizedAudioSources = validAudioSources.map(src => sanitizeAttribute(src));
                        const audioTracksAttr = sanitizeAttribute(JSON.stringify(validAudioSources));
                        const initialAudioSrc = sanitizedAudioSources[0];
                        const audioLabelSource = entryHasTitle ? `${entry.title} audio message` : 'Audio message';
                        const safeAudioLabel = sanitizeAttribute(audioLabelSource || 'Audio message');
                        const hasMultipleTracks = validAudioSources.length > 1;
                        const navDisabledAttr = hasMultipleTracks ? '' : ' disabled';
                        const audioMarkup = `
                            <div class="audio-message" tabindex="0" aria-label="${safeAudioLabel}" data-audio-index="0" data-audio-tracks="${audioTracksAttr}" data-audio-label="${safeAudioLabel}">
                                <button type="button" class="audio-nav audio-prev"${navDisabledAttr} aria-label="Previous audio message">⏮</button>
                                <button type="button" class="audio-button" aria-label="Play audio message">
                                    <span class="audio-button-icon"></span>
                                </button>
                                <div class="audio-waveform">
                                    <div class="audio-waveform-base"></div>
                                    <div class="audio-waveform-progress"></div>
                                </div>
                                <button type="button" class="audio-nav audio-next"${navDisabledAttr} aria-label="Next audio message">⏭</button>
                                <span class="audio-duration">0:00</span>
                                <audio src="${initialAudioSrc}" preload="metadata"></audio>
                            </div>
                        `;
                        projectMessageContentElements.push(
                            await addMessageWithParallelTiming(
                                'bot',
                                'audio',
                                audioMarkup
                            )
                        );
                    }
                }

                requestAnimationFrame(() => {
                    setTimeout(() => {
                        document.querySelectorAll('.message.bot').forEach(mb => {
                            mb.style.transform = '';
                        });
                        document.querySelectorAll('.message.user').forEach(mu => {
                            mu.style.transform = '';
                        });

                        // setTimeout(()=>{
                            projectMessageContentElements.forEach(mc => {
                                const mci = mc.querySelector('.message-content-inner');
                                applyTemporaryWillChange(mci, ['filter', 'opacity']);
                                mc.classList.add('sent');
                                mci.style.filter = '';
                                mci.style.opacity = '';
                            });
                        // }, 100);
                        
                        resumeAfterReveal();
                    }, 1700);
                });
            } catch (error) {
                console.error('showProject failed:', error);
                resumeAfterReveal();
                throw error;
            } finally {
                isConversationInProgress = false;
                buttons.forEach(btn => btn.classList.remove('disabled'));
            }
        }



        // Enhanced message timing with preloading
        async function addMessageWithParallelTiming(sender, type, content, welcome = false) {
            // Start typing indicator immediately
            if(welcome) showTypingIndicator(true);
            else showTypingIndicator();
            
            // Prepare the message element
            const message = document.createElement('div');
            message.className = `message ${sender}`;

            // Create a promise that resolves after minimum typing duration
            const minTypingDuration = delay(1600);
            
            const messageContent = document.createElement('div');
            messageContent.className = `message-content ${type}`;

            // Preload heavy assets while the typing animation runs
            if (type === 'image' || type === 'video' || type === 'audio') {
                preloadContent(type, content);
            }

            const messageContentInner = document.createElement('div');
            messageContentInner.className = 'message-content-inner';
            messageContentInner.innerHTML = content;

            const inlineVideoElement = type === 'video' ? messageContentInner.querySelector('video') : null;
            const inlineAudioContainer = type === 'audio' ? messageContentInner.querySelector('.audio-message') : null;


            messageContent.appendChild(messageContentInner);
            
            //Set initial style for transition animation
            messageContent.style.opacity = '0';
            messageContent.style.transform = 'translate3d(0, -100vh, 0) scale3d(1.7,1,1)';
            if(type == 'text'){
                messageContentInner.style.filter = 'blur(5px)';
                messageContentInner.style.opacity = '0.5';
            }
            else {
                messageContentInner.style.filter = 'blur(12px)';
                messageContentInner.style.opacity = '0.75';
            }
            if(!welcome){
                if(sender == 'bot') message.style.transform = 'translate3d(-20vw, 0, 0)';
                else if(sender == 'user') message.style.transform = 'translate3d(20vw, 0, 0)';
            }

            message.appendChild(messageContent);
            
            // Wait for minimum typing duration AND preload to complete
            await minTypingDuration;
            // Now reveal the message with animation
            hideTypingIndicator();
            
            // Add to DOM (but invisible)
            const chatContainer = getChatContainer();
            const chatSpaceAfter = chatContainer.lastElementChild;
            chatContainer.insertBefore(message, chatSpaceAfter);

            const surfaceOptions = {
                ...glassSurfaceSettings.message.base
            };

            if (type === 'image' || type === 'video') {
                Object.assign(surfaceOptions, glassSurfaceSettings.message.mediaOverrides);
            }

            const surfaceState = GlassSurfaceFX.attach({
                host: messageContent,
                contentElement: messageContentInner,
                className: 'message-glass',
                options: surfaceOptions
            });

            if (inlineVideoElement) {
                inlineVideoElement.playsInline = true;
                registerVideoElement(inlineVideoElement);
            }
            if (inlineAudioContainer) {
                registerAudioMessage(inlineAudioContainer);
            }

            //Wait glass effect ready promise resolve
            // if (surfaceState && surfaceState.readyPromise) {
            //    await surfaceState.readyPromise;
            // }
            
            //Make message appear
            requestAnimationFrame(() => {
                // Batch layout reads to keep reveal smooth
                messageContent.offsetHeight;
                messageContentInner.offsetHeight;

                let messageTransformTarget = null;
                
                if (messageTransformTarget !== null) {
                    applyTemporaryWillChange(message, 'transform');
                }
                if (!welcome){
                    if (sender == 'bot'){
                        const translateX = getTranslationLimits(message.firstElementChild, chatContainer, 'left') + messageTranslateOffset;
                        messageTransformTarget = `translate3d(${translateX}px, 0, 0)`;
                    }
                    else if (sender == 'user'){
                        const translateX = getTranslationLimits(message.firstElementChild, chatContainer, 'right') - messageTranslateOffset;
                        messageTransformTarget = `translate3d(${translateX}px, 0, 0)`;
                    }
                }

                applyTemporaryWillChange(messageContent, ['opacity', 'transform']);
                

                if (messageTransformTarget !== null){
                    message.style.transform = messageTransformTarget;
                }

                messageContent.style.opacity = '';
                messageContent.style.transform = '';
            });

            //Check if user triggered manual scroll
            if (!mannualScrollOn){
                requestAnimationFrame(() => {
                    // Scroll 
                    if(welcome){
                        scrollToCenter(message);
                        setTimeout(()=>{
                            messageContentInner.style.filter = '';
                            messageContentInner.style.opacity = '';
                        }, 700)
                        setTimeout(()=>{
                            messageContent.classList.add('sent');
                        }, 1500);
                    }
                    else scrollToBottom();
                });
            }
            return messageContent;
        }

        // Typing indicator functions
        function showTypingIndicator(welcome = false) {
            const indicator = document.getElementById('typingIndicator');
            if (!indicator) return;

            const chatContainer = getChatContainer();
            const chatSpaceAfter = chatContainer.lastElementChild;
            chatContainer.insertBefore(indicator, chatSpaceAfter);
            indicator.classList.add('active');

            // Apply glass surface effect to typing indicator
            const typingDots = indicator.querySelector('.typing-dots');
            if (typingDots) {
                GlassSurfaceFX.attach({
                    host: typingDots,
                    contentElement: typingDots.querySelector('.typing-dots-content'),
                    className: 'typing-glass',
                    options: { ...glassSurfaceSettings.typingIndicator }
                });
                // GlassSurfaceFX.forceRefresh(typingDots);

                typingDots.offsetHeight;
                typingDots.classList.add('active');
            }

            if (!mannualScrollOn){
                requestAnimationFrame(()=>{
                    if(welcome) scrollToCenter(indicator);
                    else {
                        scrollToBottom();
                    }              
                });
            }
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (!indicator) return;
            

            const typingDots = indicator.querySelector('.typing-dots');
            if (typingDots) {
                typingDots.classList.remove('active');
            }
            indicator.classList.remove('active');

            
        }

// === ENHANCED MEDIA OVERLAY WITH ZOOM ===

        let zoomAbortController = null;

        // Zoom state variables
        let zoomLevel = 1;
        let zoomPanX = 0;
        let zoomPanY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;
        let activeDragPointerId = null;
        let pendingZoomFrame = null;
        let currentMediaElement = null;
        let isDesktop = false;

        function checkIfDesktop() {
            const canHover = window.matchMedia('(hover: hover)').matches;
            const hasFinePointer = window.matchMedia('(pointer: fine)').matches;
            const previousDesktop = isDesktop;

            if (canHover === true && hasFinePointer === true) {
                isDesktop = true;
            } else if (canHover === false && hasFinePointer === false) {
                isDesktop = false;
            } else {
                // Fallback for browsers without matchMedia or returning mixed results
                isDesktop = !('ontouchstart' in window) && navigator.maxTouchPoints === 0;
            }

            if (isDesktop !== previousDesktop || !rippleGridState.instance) {
                initOrUpdateRippleGrid();
            }
        }

        // Helper: pointer coords relative to OVERLAY CENTER (not top-left)
        function getCenteredPointer(container, clientX, clientY) {
        const rect = container.getBoundingClientRect();
        return {
            x: clientX - (rect.left + rect.width / 2),
            y: clientY - (rect.top  + rect.height / 2),
        };
        }

        // evt is optional so existing onclicks still work
        async function openMediaOverlay(type, src, evt) {
            let sourceVideo = null;
            if (evt) {
                if (typeof evt.preventDefault === 'function') {
                    evt.preventDefault();
                }
                if (typeof evt.stopPropagation === 'function') {
                    evt.stopPropagation();
                }
                const target = evt.currentTarget || evt.target || null;
                if (target && target.tagName === 'VIDEO') {
                    sourceVideo = target;
                }
            }

            if (sourceVideo && !sourceVideo.paused) {
                sourceVideo.pause();
            }

            const overlay = document.getElementById('mediaOverlay');
            const content = document.getElementById('overlayContent');
            const overlayContainer = overlay.querySelector('.media-overlay-content');
            const zoomControls = document.getElementById('zoomControls');

            const existingOverlayVideo = content.querySelector('video');
            if (existingOverlayVideo) {
                existingOverlayVideo.pause();
                deregisterVideoElement(existingOverlayVideo);
            }

            resetZoom(false); // Reset state without applying transform
            isDragging = false;
            activeDragPointerId = null;
            pauseAllManagedVideos();
            pauseAllManagedAudios();

            checkIfDesktop();

            if (type === 'image') {
                const img = new Image();
                img.decoding = 'async';
                img.src = src;
                img.alt = "Full size image";
                content.innerHTML = '';
                content.appendChild(img);
                currentMediaElement = img;
                img.style.willChange = 'transform';

                if (isDesktop) {
                    overlayContainer.classList.add('zoom-enabled');
                    zoomControls.classList.add('visible');
                    
                } else {
                    overlayContainer.classList.remove('zoom-enabled');
                    zoomControls.classList.remove('visible');
                }

                let decoded = false;
                if (typeof img.decode === 'function') {
                    try {
                        await img.decode();
                        decoded = true;
                    } catch (err) {
                        // Ignore decode errors; load listener will handle fallback
                    }
                }

                if (!decoded) {
                    await new Promise((resolve) => {
                        img.addEventListener('load', resolve, { once: true });
                        img.addEventListener('error', resolve, { once: true });
                    });
                }

                if (isDesktop) {
                    setupZoomHandlers(overlayContainer, img);
                }
            } else if (type === 'video') {
                content.innerHTML = `<video src="${src}" controls autoplay preload="metadata" playsinline></video>`;
                currentMediaElement = null;
                overlayContainer.classList.remove('zoom-enabled');
                zoomControls.classList.remove('visible');

                const overlayVideo = content.querySelector('video');
                if (overlayVideo) {
                    overlayVideo.playsInline = true;
                    registerVideoElement(overlayVideo);
                    const playPromise = overlayVideo.play();
                    if (playPromise && typeof playPromise.then === 'function') {
                        playPromise.catch(() => {});
                    }
                }
            }

            overlay.classList.add('active');
            requestAnimationFrame(() => {
                GlassSurfaceFX.attach({
                    host: zoomControls,
                    contentElement: zoomControls,
                    className: 'overlay-glass',
                    options: { ...glassSurfaceSettings.zoomControls }
                });
                // GlassSurfaceFX.forceRefresh(zoomControls);
            });
        }


        function setupZoomHandlers(container, img) {
            if (zoomAbortController) zoomAbortController.abort();
            zoomAbortController = new AbortController();
            const { signal } = zoomAbortController;

            // --- Wheel zoom (keep cursor as focal point) ---
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const oldZoom = zoomLevel;
                const newZoom = Math.max(1, Math.min(5, zoomLevel * (1 - e.deltaY * 0.001)));

                const { x, y } = getCenteredPointer(container, e.clientX, e.clientY);

                // Keep the point under the cursor stationary
                zoomPanX = zoomPanX + (x - zoomPanX) * (1 - newZoom / oldZoom);
                zoomPanY = zoomPanY + (y - zoomPanY) * (1 - newZoom / oldZoom);
                zoomLevel = newZoom;

                if (zoomLevel <= 1.01) {
                    resetZoom();
                } else {
                    requestZoomUpdate(img);
                }
            }, { passive: false, signal });

            // --- Double-click to zoom (toggle between 1x and 2x at click point) ---
            // container.addEventListener('dblclick', (e) => {
            //     e.preventDefault();
            //     if (zoomLevel > 1) {
            //     resetZoom();
            //     } else {
            //     const oldZoom = zoomLevel;
            //     const newZoom = 2;
            //     const { x, y } = getCenteredPointer(container, e.clientX, e.clientY);

            //     zoomPanX = zoomPanX + (x - zoomPanX) * (1 - newZoom / oldZoom);
            //     zoomPanY = zoomPanY + (y - zoomPanY) * (1 - newZoom / oldZoom);
            //     zoomLevel = newZoom;
            //     applyZoom(img);
            //     }
            // }, { signal });

            // --- Drag to pan ---
            container.addEventListener('pointerdown', (e) => startDrag(e, container), { signal });
            container.addEventListener('pointermove', handleDrag, { signal });
            container.addEventListener('pointerup', endDrag, { signal });
            container.addEventListener('pointercancel', endDrag, { signal });
        }


        function startDrag(e, container) {
            if (!isDesktop || !currentMediaElement) return;

            const target = e.target;
            if (target && target.closest && target.closest('.zoom-controls')) return;
            if (target !== currentMediaElement) return;
            if (zoomLevel <= 1 || (e.button !== undefined && e.button !== 0)) return;
            if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== 'pen') return;

            e.preventDefault();
            isDragging = true;

            const pointerId = typeof e.pointerId === 'number' ? e.pointerId : null;
            activeDragPointerId = pointerId;
            if (pointerId !== null && typeof container.setPointerCapture === 'function') {
                container.setPointerCapture(pointerId);
            }

            dragStartX = e.clientX;
            dragStartY = e.clientY;
            lastPanX = zoomPanX;
            lastPanY = zoomPanY;
            container.classList.add('dragging'); // CSS will disable transition while dragging
        }

        function handleDrag(e) {
            if (!isDragging || !currentMediaElement) return;
            if (activeDragPointerId !== null && typeof e.pointerId === 'number' && e.pointerId !== activeDragPointerId) return;
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;

            zoomPanX = lastPanX + dx;
            zoomPanY = lastPanY + dy;

            requestZoomUpdate(currentMediaElement);
        }


        function endDrag(e) {
            if (!isDragging) return;
            if (e && activeDragPointerId !== null && typeof e.pointerId === 'number' && e.pointerId !== activeDragPointerId) return;
            isDragging = false;
            const container = document.querySelector('.media-overlay-content');
            if (container && activeDragPointerId !== null && typeof container.releasePointerCapture === 'function') {
                if (!container.hasPointerCapture || container.hasPointerCapture(activeDragPointerId)) {
                    container.releasePointerCapture(activeDragPointerId);
                }
            }
            activeDragPointerId = null;
            if (container) container.classList.remove('dragging');
        }


        function constrainPan(img) {
            if (!img) return;
            const container = img.closest('.media-overlay-content') || img.parentElement?.parentElement;
            if (!container) return;

            // The image's displayed size after scaling
            const scaledWidth = img.clientWidth * zoomLevel;
            const scaledHeight = img.clientHeight * zoomLevel;

            // How much the image overhangs the container on each side
            const overhangX = Math.max(0, (scaledWidth - container.clientWidth) / 2);
            const overhangY = Math.max(0, (scaledHeight - container.clientHeight) / 2);

            // Limit the pan to the overhang values
            zoomPanX = Math.max(-overhangX, Math.min(overhangX, zoomPanX));
            zoomPanY = Math.max(-overhangY, Math.min(overhangY, zoomPanY));
        }

        // Apply current zoom & pan
        function applyZoom(img) {
            constrainPan(img);
            img.style.transformOrigin = 'center center';
            img.style.transform = `translate3d(${zoomPanX}px, ${zoomPanY}px, 0) scale(${zoomLevel})`;
        }

        function requestZoomUpdate(img = currentMediaElement) {
            if (!img) return;
            if (pendingZoomFrame !== null) return;
            pendingZoomFrame = requestAnimationFrame(() => {
                pendingZoomFrame = null;
                applyZoom(img);
            });
        }

        // Zoom control buttons (center is 0,0 in centered coords)
        function zoomIn() {
            if (!currentMediaElement || !isDesktop) return;
            const oldZoom = zoomLevel;
            const newZoom = Math.min(5, zoomLevel + 0.5);
            const x = 0, y = 0;

            zoomPanX = zoomPanX + (x - zoomPanX) * (1 - newZoom / oldZoom);
            zoomPanY = zoomPanY + (y - zoomPanY) * (1 - newZoom / oldZoom);
            zoomLevel = newZoom;

            if (zoomLevel <= 1.01) {
                resetZoom();
            } else {
                requestZoomUpdate(currentMediaElement);
            }
        }

        function zoomOut() {
            if (!currentMediaElement || !isDesktop) return;
            const oldZoom = zoomLevel;
            const newZoom = Math.max(1, zoomLevel - 0.5);
            const x = 0, y = 0;

            zoomPanX = zoomPanX + (x - zoomPanX) * (1 - newZoom / oldZoom);
            zoomPanY = zoomPanY + (y - zoomPanY) * (1 - newZoom / oldZoom);
            zoomLevel = newZoom;

            if (zoomLevel <= 1.01) {
                resetZoom();
            } else {
                requestZoomUpdate(currentMediaElement);
            }
        }

        function resetZoom(apply = true) {
            zoomLevel = 1;
            zoomPanX = 0;
            zoomPanY = 0;
            if (pendingZoomFrame !== null) {
                cancelAnimationFrame(pendingZoomFrame);
                pendingZoomFrame = null;
            }
            if (apply && currentMediaElement) {
                currentMediaElement.style.transformOrigin = 'center center';
                currentMediaElement.style.transform = 'translate3d(0, 0, 0) scale(1)';
            }
        }

        function closeMediaOverlay() {
            const overlay = document.getElementById('mediaOverlay');
            if (!overlay) return;

            const overlayContainer = overlay.querySelector('.media-overlay-content');
            pauseAllManagedAudios();

            // Abort zoom handlers
            if (zoomAbortController) {
                zoomAbortController.abort();
                zoomAbortController = null;
            }

            if (overlayContainer && activeDragPointerId !== null && typeof overlayContainer.releasePointerCapture === 'function') {
                if (!overlayContainer.hasPointerCapture || overlayContainer.hasPointerCapture(activeDragPointerId)) {
                    overlayContainer.releasePointerCapture(activeDragPointerId);
                }
            }


            const overlayContentEl = document.getElementById('overlayContent');
            const overlayVideo = overlayContentEl ? overlayContentEl.querySelector('video') : null;
            if (overlayVideo) {
                overlayVideo.pause();
                deregisterVideoElement(overlayVideo);
            }
            isDragging = false;
            activeDragPointerId = null;

            if (currentMediaElement) {
                currentMediaElement.style.willChange = '';
            }
            resetZoom(false);
            currentMediaElement = null;

            overlay.classList.add('closing');

            setTimeout(() => {
                overlay.classList.remove('active', 'closing');
                document.getElementById('overlayContent').innerHTML = '';

                const container = overlay.querySelector('.media-overlay-content');
                if (container) container.classList.remove('zoom-enabled', 'dragging');

                document.getElementById('zoomControls').classList.remove('visible');
            }, 400);
        }


        // === (end of enhanced media overlay with zoom) ===


    // === UNITILITY FUNCTIONS === 
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        const temporaryWillChangeMap = new WeakMap();

        function parseTimeToMs(timeString) {
            if (!timeString) return 0;
            return timeString.split(',').reduce((max, part) => {
                const value = part.trim();
                if (!value) return max;
                const number = parseFloat(value);
                if (Number.isNaN(number)) return max;
                if (value.endsWith('ms')) return Math.max(max, number);
                if (value.endsWith('s')) return Math.max(max, number * 1000);
                return Math.max(max, number);
            }, 0);
        }

        function getMaxTransitionTime(element) {
            if (!element) return 0;
            const styles = window.getComputedStyle(element);
            const durations = styles.transitionDuration ? styles.transitionDuration.split(',') : [];
            const delays = styles.transitionDelay ? styles.transitionDelay.split(',') : [];
            if (!durations.length) return 0;
            return durations.reduce((max, duration, index) => {
                const total = parseTimeToMs(duration) + parseTimeToMs(delays[index] || delays[delays.length - 1] || '0s');
                return Math.max(max, total);
            }, 0);
        }

        function getMaxAnimationTime(element) {
            if (!element) return 0;
            const styles = window.getComputedStyle(element);
            const durations = styles.animationDuration ? styles.animationDuration.split(',') : [];
            const delays = styles.animationDelay ? styles.animationDelay.split(',') : [];
            if (!durations.length) return 0;
            return durations.reduce((max, duration, index) => {
                const total = parseTimeToMs(duration) + parseTimeToMs(delays[index] || delays[delays.length - 1] || '0s');
                return Math.max(max, total);
            }, 0);
        }

        function applyTemporaryWillChange(element, properties) {
            if (!element) return;

            const propertyList = Array.isArray(properties) ? properties.filter(Boolean) : [properties];
            const props = propertyList.filter(Boolean).join(', ');
            if (!props) return;

            const existing = temporaryWillChangeMap.get(element);
            if (existing) {
                element.removeEventListener('transitionend', existing.onTransitionEnd);
                element.removeEventListener('animationend', existing.onAnimationEnd);
                clearTimeout(existing.timeoutId);
                temporaryWillChangeMap.delete(element);
            }

            element.style.willChange = props;

            const cleanup = () => {
                const state = temporaryWillChangeMap.get(element);
                if (!state) return;
                if (element.style.willChange === state.props) {
                    element.style.willChange = '';
                }
                element.removeEventListener('transitionend', state.onTransitionEnd);
                element.removeEventListener('animationend', state.onAnimationEnd);
                clearTimeout(state.timeoutId);
                temporaryWillChangeMap.delete(element);
            };

            const onTransitionEnd = (event) => {
                if (event.target === element) {
                    cleanup();
                }
            };

            const onAnimationEnd = (event) => {
                if (event.target === element) {
                    cleanup();
                }
            };

            const fallbackDuration = Math.max(
                getMaxTransitionTime(element),
                getMaxAnimationTime(element)
            ) || 600;

            const timeoutId = setTimeout(cleanup, fallbackDuration + 50);

            const state = { props, timeoutId, onTransitionEnd, onAnimationEnd };
            temporaryWillChangeMap.set(element, state);

            element.addEventListener('transitionend', onTransitionEnd);
            element.addEventListener('animationend', onAnimationEnd);
        }


        function getTranslationLimits(childElement, parentElement, direction) {
            // Get the dimensions and position of the parent and child elements
            // relative to the viewport.
            const parentRect = parentElement.getBoundingClientRect();
            const childRect = childElement.getBoundingClientRect();
            let parentPadding = parseFloat(window.getComputedStyle(parentElement).paddingLeft);

            let maxTranslate = 0;
            // To move LEFT:
            // The child's right edge must align with the parent's left edge.
            // The distance needed to move is parentRect.left - childRect.left.
            // This will be a negative value, suitable for translateX.
            if (direction == 'left') {maxTranslate = parentRect.left - (childElement.offsetLeft + childElement.offsetParent.offsetLeft);}

            // To move RIGHT:
            // The child's left edge must align with the parent's right edge.
            // The distance needed to move is parentRect.right - childRect.right.
            // This will be a positive value.
            if (direction == 'right') {maxTranslate = parentRect.right - (childElement.offsetLeft + childElement.offsetWidth + childElement.offsetParent.offsetLeft + parentPadding);}

            return maxTranslate;
        }

        // === ADAPTIVE QUALITY MANAGEMENT ===
        function enterRecoveryMode(now = performance.now()) {
            if (qualityState.mode === 'recovery') return;

            qualityState.mode = 'recovery';
            qualityState.qualityMultiplier = 0.8;
            qualityState.lastSwitch = now;
            GlassSurfaceFX.refreshAll();

            if (Array.isArray(letters) && letters.length > 0) {
                letters = letters.slice(-190);
            }

            document.dispatchEvent(new CustomEvent('qualitychange', { detail: { mode: qualityState.mode } }));

            console.log('[quality] recovery mode');
        }

        function enterHighMode(now = performance.now()) {
            if (qualityState.mode === 'high') return;

            qualityState.mode = 'high';
            qualityState.qualityMultiplier = 1;
            qualityState.lastSwitch = now;
            GlassSurfaceFX.refreshAll();

            document.dispatchEvent(new CustomEvent('qualitychange', { detail: { mode: qualityState.mode } }));

            console.log('[quality] high mode');
        }

        function monitorPerformance(now) {
            const timestamp = typeof now === 'number' ? now : performance.now();
            const delta = timestamp - lastFpsSampleTime;
            lastFpsSampleTime = timestamp;

            if (delta > 0 && delta < 250) {
                fpsSamples.push(delta);
                fpsSum += delta;
                if (fpsSamples.length > MAX_FPS_SAMPLES) {
                    fpsSum -= fpsSamples.shift();
                }

                const averageDelta = fpsSum / fpsSamples.length;
                const fps = 1000 / averageDelta;

                if (qualityState.mode === 'high') {
                    if (fps < QUALITY_THRESHOLDS.dropFps) {
                        if (lowFpsSince === null) {
                            lowFpsSince = timestamp;
                        } else if (timestamp - lowFpsSince >= QUALITY_THRESHOLDS.dropDuration) {
                            enterRecoveryMode(timestamp);
                            lowFpsSince = null;
                        }
                    } else {
                        lowFpsSince = null;
                    }
                    highFpsSince = null;
                } else {
                    if (fps > QUALITY_THRESHOLDS.raiseFps) {
                        if (highFpsSince === null) {
                            highFpsSince = timestamp;
                        } else if (timestamp - highFpsSince >= QUALITY_THRESHOLDS.raiseDuration) {
                            enterHighMode(timestamp);
                            highFpsSince = null;
                        }
                    } else {
                        highFpsSince = null;
                    }
                    lowFpsSince = null;
                }
            }

            requestAnimationFrame(monitorPerformance);
        }

        requestAnimationFrame(monitorPerformance);

        document.addEventListener('qualitychange', () => {
            if (bgCanvas && bgCtx) {
                resizeCanvas(true);
            }

            GlassSurfaceFX.refreshAll();
        });

        // ============ IMPROVED SCROLLING FUNCTIONS WITH LERP ============
        
        // Scroll animation state
        let scrollAnimationId = null;
        let currentScrollTarget = null;
        let mannualScrollOn = false;
        
        // Linear interpolation function
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        // Smooth scroll animation using requestAnimationFrame
        function animateScroll(container, targetPosition) {
            // Cancel any existing scroll animation
            if (scrollAnimationId) {
                cancelAnimationFrame(scrollAnimationId);
                scrollAnimationId = null;
            }

            // Round target position to avoid sub-pixel rendering
            currentScrollTarget = Math.floor(targetPosition);
            
            const lerpFactor = 0.06; // Adjust this for scroll speed (0.05 = slow, 0.2 = fast)
            const closeEnoughThreshold = 5; // Stop when close enough
            const minimumMovement = 1; // Skip movements smaller than this
            
            function step() {
                // Get current position
                const currentPosition = container.scrollTop;
                const distance = Math.abs(currentScrollTarget - currentPosition);
                
                // Check if we're close enough to the target
                if (distance < closeEnoughThreshold) {
                    // Snap (or no snap) to exact target and stop animation
                    // container.scrollTop = currentScrollTarget;
                    scrollAnimationId = null;
                    currentTarget = null;
                } 
                else {
                    // Calculate new position using lerp
                    const newPosition = lerp(currentPosition, currentScrollTarget, lerpFactor);
                    const movement = Math.abs(newPosition - currentPosition);

                    // Only update if movement is significant enough
                    if (movement > minimumMovement) {
                        // Round to avoid sub-pixel rendering
                        container.scrollTop = Math.ceil(newPosition);
                        scrollAnimationId = requestAnimationFrame(step);
                    }
                    else{
                        scrollAnimationId = null;
                        currentTarget = null;
                    }
                }
            }
            // Start the animation
            scrollAnimationId = requestAnimationFrame(step);
        }
        
        function scrollToBottom() {
            const chatContainer = getChatContainer();
            
            // Get current scroll position
            let currentScrollTop = chatContainer.scrollTop;
            
            // Calculate the maximum scrollTop value (the very bottom)
            let maxScrollTop = chatContainer.scrollHeight - chatContainer.clientHeight;
            
            // Calculate the desired offset in pixels (50vh)
            const offset = Math.round(0.5 * window.innerHeight);
            
            // Subtract the offset from the maximum scroll position
            let scrollTopTarget = maxScrollTop - offset;

             // Use Math.max to ensure the target isn't a negative number and make sure it never scroll up
            scrollTopTarget = Math.max(currentScrollTop, scrollTopTarget);
    
            // But also don't exceed the maximum possible scroll
            scrollTopTarget = Math.min(scrollTopTarget, maxScrollTop);
            
            // Only animate if there's actually a change needed
            if (Math.abs(scrollTopTarget - currentScrollTop) > 0) {
                animateScroll(chatContainer, scrollTopTarget);
            }
        }
        
        // Scroll to center a specific element
        function scrollToCenter(element) {
            const chatContainer = getChatContainer();
            
            // Use cached container dimensions when possible
            // const containerRect = chatContainer.getBoundingClientRect();
            // const elementRect = element.getBoundingClientRect();

            // Calculate the element's position relative to the container
            const elementTop = element.offsetTop;
            const elementHeight = element.offsetHeight;
            
            // Get container styles only once
            const containerComputedStyle = window.getComputedStyle(chatContainer);
            const containerPaddingTop = parseFloat(containerComputedStyle.paddingTop);
            const containerPaddingBottom = parseFloat(containerComputedStyle.paddingBottom);
            const containerHeight = chatContainer.offsetHeight - containerPaddingTop - containerPaddingBottom;
            
            // Calculate scroll position to center the element
            const scrollTopTarget = elementTop + (elementHeight / 2) - (containerHeight / 2);

            // Start smooth scroll animation
            animateScroll(chatContainer, scrollTopTarget);
        }

        function cancelScrollAnimation() {
            if (scrollAnimationId) {
                mannualScrollOn = true;
                cancelAnimationFrame(scrollAnimationId);
                scrollAnimationId = null;
            }
        }

        // Close overlay on background click
        // document.getElementById('mediaOverlay').addEventListener('click', function(e) {
        //     if (e.target === this) {
        //         closeMediaOverlay();
        //     }
        // });
        // Clicks inside the content should NOT close:
        // document.getElementById('overlayContent').addEventListener('click', (e) => e.stopPropagation());


        //Listen for custom ready event for webgl and canvas
        window.whenEffectsReady().then(({ canvas, webgl }) => {
            console.log('Both effects ready', canvas, webgl);
        });


        // Initialize on load
        window.onload = () => {
            initCanvas();
            initializeButtons();

            // Check if desktop on load
            checkIfDesktop();
            initOrUpdateRippleGrid();
            
            // Update desktop check on resize
            window.addEventListener('resize', checkIfDesktop, { passive: true });

            // Welcome message with new timing
            setTimeout(async () => {
                await addMessageWithParallelTiming('bot', 'text', 'Welcome to Digital Double, Pavilion for The Wrong Biennale. Select a project below to explore.', true);
                const buttons = document.querySelectorAll('.project-button');
                buttons.forEach(btn => btn.classList.remove('disabled'));

                //Add manual scroll listener after welcome message
                const chatContainer = getChatContainer();
                // Detect mouse wheel scrolling
                chatContainer.addEventListener('wheel', cancelScrollAnimation, { passive: true });

                // Detect touch scrolling
                chatContainer.addEventListener('touchmove', cancelScrollAnimation, { passive: true });

                // Detect keyboard scrolling
                document.addEventListener('keydown', (e) => {
                    // Only cancel if the chat container is the scroll target or contains the focused element
                    const scrollKeys = ['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End', ' '];
                    if (scrollKeys.includes(e.key)) {
                        cancelScrollAnimation();
                    }
                }, { passive: true });
            }, 500);
        };

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            destroyRippleGrid();
            stopCanvasAnimation();
            pauseAllManagedVideos();
            pauseAllManagedAudios();
            if (scrollAnimationId) {
                cancelAnimationFrame(scrollAnimationId);
            }
        });
    </script>
</body>
</html>






